





















                                               TM                                               TM
                                        USNET                                        USNET
                                PROCESSOR INDEPENDENT                                PROCESSOR INDEPENDENT
                                       TCP/IP                                       TCP/IP
                                    USER'S MANUAL                                    USER'S MANUAL


                                 September 12, 1994














           All rights reserved.  No part of this document may be copied or
          reproduced in any form or by any means without the prior written
                   consent of United States Software Corporation.

                  Copyright 1993 United States Software Corporation
             USNET +  and U S Software + are trademarks of United States
                                Software Corporation






             Copyright 1993 United States Software Corporation.  All rights
             reserved.

             No part of this publication may be reproduced, translated into
             another language, stored in a retrieval system, or
             transmitted, in any form or by any means, electronic,
             mechanical, photocopying, recording, or otherwise, without the
             prior written consent of United States Software Corporation.

             United States Software Corporation makes no warranty of any
             kind with regard to this material, including, but not limited
             to, the implied warranties of merchantability and fitness for
             a particular purpose.  United States Software Corporation
             assumes no responsibility for any errors that may appear in
             this document.  United States Software Corporation makes no
             commitment to update nor to keep current the information
             contained in this document.


             United States Software Corporation             United States Software Corporation
             14215 NW Science Park Drive
             Portland, OR 97229
             (503) 641-8446
             FAX (503) 644-2413


































          i          i








          1. INTRODUCTION............................................1-1          1. INTRODUCTION............................................1-1

          SUPPORTED PROTOCOLS........................................1-1
          USNET SOURCE...............................................1-3

          2. INSTALLING USNET........................................2-1          2. INSTALLING USNET........................................2-1

          FOR DOS....................................................2-1
          FOR UNIX...................................................2-1
          SIMPLE TEST................................................2-1
          BUILDING LTEST.............................................2-2
          DISPLAYING TRACE DATA......................................2-3

          3. USNET CONFIGURATION MANAGER.............................3-1          3. USNET CONFIGURATION MANAGER.............................3-1

          MAIN SCREEN................................................3-1
          KEYS AND OPERATIONS........................................3-1
          STATUS INDICATORS..........................................3-2
          NETWORK CONFIGURATION TABLE................................3-2
          ENTERING AND MODIFYING TABLE ENTRIES.......................3-3
          STATUS WINDOW..............................................3-3
          ERROR MESSAGES.............................................3-4

          4. CONFIGURING USNET.......................................4-1          4. CONFIGURING USNET.......................................4-1

          OVERVIEW...................................................4-1
          NETWORK CONFIGURATION......................................4-2
          TIMER SUPPORT..............................................4-6
          DISPLAY AND KEYBOARD SUPPORT...............................4-7
          HOSTNAME...................................................4-8
          PROTOCOL SUPPORT...........................................4-8
          DRIVER SUPPORT.............................................4-8
          LOCAL PARAMETERS..........................................4-10

          5. USER INTERFACE..........................................5-1          5. USER INTERFACE..........................................5-1

          INCLUDE FILES..............................................5-1
          INITIALIZATION.............................................5-1
          CONNECTIONS................................................5-3
          OPEN, CLOSE, READ, WRITE...................................5-4
          OTHER USEFUL EXAMPLES......................................5-8

          6. MULTITASKING............................................6-1          6. MULTITASKING............................................6-1

          TASK CREATION..............................................6-1
          YIELDING CONTROL...........................................6-2
          PRE-EMPTION................................................6-2
          SIGNALING..................................................6-3

          7. DEVICE DRIVERS..........................................7-1          7. DEVICE DRIVERS..........................................7-1

          INTERRUPT HANDLING.........................................7-8




                                                                   ii                                                                   ii                                                                   __






             CONFIGURING FOR AN UNSUPPORTED PROCESSOR...................7-9
             ERROR CODES...............................................7-10
             WRITING A DEVICE DRIVER...................................7-10
             CHARACTER DRIVERS.........................................7-11
             BLOCK DRIVERS.............................................7-19
             ADAPTERS..................................................7-31

             8. APPLICATION ROUTINES....................................8-1             8. APPLICATION ROUTINES....................................8-1

             TFTP, FTP..................................................8-1

             9. TELNET..................................................9-1             9. TELNET..................................................9-1


             10. TEST PROGRAMS.........................................10-1             10. TEST PROGRAMS.........................................10-1

             PING......................................................10-1
             FTTEST....................................................10-1
             EMTEST....................................................10-2
             SOTEST....................................................10-2
             MTTEST....................................................10-2

             11. ADDING AND CHANGING PROTOCOLS.........................11-1             11. ADDING AND CHANGING PROTOCOLS.........................11-1


             12. BSD SOCKET INTERFACE..................................12-1             12. BSD SOCKET INTERFACE..................................12-1

             ABOUT BSD SOCKETS.........................................12-1
             USING BSD SOCKETS.........................................12-1
             A COMPLETE CLIENT-SERVER EXAMPLE.........................12-12

             13. PERFORMANCE...........................................13-1             13. PERFORMANCE...........................................13-1

             BENCHMARKS................................................13-1
























          iii          iii









             1.   INTRODUCTION             1.   INTRODUCTION             _________________
             --------------------------------------------------------------

             USNET is a library that supports TCP/IP protocols and
             applications in embedded real-time environments.  The
             protocols are:

               TCP     Transmission Control Protocol, transport layer with
                       connections, flow control and error correction.
               UDP     User Datagram Protocol, simple connectionless
                  transport layer.
               IP      Internet Protocol, the network layer.
               ICMP    Internet Control Message Protocol, part of IP for
                       practical purposes.
               ARP     Address Resolution Protocol, gets hardware address
                       using Internet address.
               RARP    Reverse Address Resolution Protocol, gets Internet
                       address using hardware address.


             The following picture illustrates the logical relationships
             between the protocols:

                                 +---------+                                 +---------+
                                  applicat                                 |         |                                 |         |
                                    ion                                 |         |                                 |         |
                                 |---------|                                 |---------|
                                  TCP/UDP                                 |         |                                 |         |
                                 |---------|                                 |---------|
                                  IP/ICMP                                 |         |                                 |         |
                                 |---------|                                 |---------|
                                    Link                                 |         |                                 |         |
                                  Control                                 |         |                                 |         |
                                 |---------|                                 |---------|
                                   device                                 |         |                                 |         |
                                   driver                                 |         |                                 |         |
                                 +---------+                                 +---------+
                                      +
                                      +
                                      +
                        +++++++++++++++++++++++++++++++++++++++
                             network


             SUPPORTED PROTOCOLS             SUPPORTED PROTOCOLS

             The supported applications and application protocols are:

               FTP     File Transfer Protocol, file transfer using TCP
               TFTP    Trivial File Transfer Protocol, file transfer using
             UDP



             1             1             _ USNET User's Manual               ___________________






            TELNET  terminal emulation and remote login
            PING    check if host responds, using ICMP
            BOOTP   Bootstrap Protocol


          USNET was designed and built using the protocol stack                                                 ______________
          technology.  It is not tied to any particular protocols.

          To accommodate the special requirements of the embedded world,
          the USNET design considers:

          - Size:  The complete TCP/IP protocol, including all needed            Size                                           all 
            subroutines but excluding the application level, takes up
            about 20 kilobytes on an x86.  The protocols are
            individually configured, so the minimum system is even
            smaller than this.  The fixed RAM requirement is typically
            less than 1 kilobyte.  Each active connection needs buffer
            space; this is dynamically allocated and the requirements
            depend on the application.

          - Adaptability:  The library is entirely in C, and will work            Adaptability
            with any 8-bit, 16-bit or 32-bit processor that has an ANSI
            C compiler.  USNET is written in simple basic ANSI code that
            will cause trouble only in very unsatisfactory compilers.
            (Look out for long integer and function pointer support in
            8-bit compilers.)

          - Clarity:  The code does not contain any conditional controls            Clarity
            for different compilers or processors.  There are absolutely
            no statements of the form

               #ifdef COMPILER_SOSO
                    do it so-so
               #else
                    do it right
               #endif

            All support for different byte ordering or word size is
          invisible to the user.

          - External support:  The package as delivered uses only a few            External support: 
            basic ANSI C services, and runs without multitasking.
            Methods are provided to configure a multitasker and to
            replace the ANSI services, see section 3 for this.

          - Packaging:  USNET is configured in source.  The applications            Packaging
            are packaged as C subroutines.  There are only about 30
            external routines; the names are not likely to conflict with
            any other names.  The stack frame is kept as small as
            possible.

          - Re-entrancy:  The code is re-entrant even when used with            Re-entrancy
            pre-emptive multitasking and nested interrupts.




          2          2                                       USNET User's Manual                                                  ___________________






             - ROM residence:  The code is rommable in a wide sense of the               ROM residence
               word: all initialized data is type "const", and there are no
               attempts to change code or constants.

             - Device drivers:  USNET considers drivers as extensions to               Device drivers
               hardware, and uses a separate data link layer.  This results
               in short and simple drivers.


             The code has been tested for a large number of different
             processors and compilers.  It comes with extensive drop-in
             support:

               makefiles
               drivers
               interrupt code
               sample timer and display code
               sample startup code.


             The TCP/IP support of USNET lacks at present the following
             feature:

               USNET has a one-level network hierarchy: hosts only.  The
               configuration table is fixed.  There is no routing
               application or routing protocol.  You can configure a
               network of any size, but the lack of hierarchy will make
               this cumbersome if you have hundreds of hosts.


             USNET SOURCE             USNET SOURCE

             USNET provides drop-in support for a number of different
             compilers and hardware and is installed with a particular
             hardware/compiler combination in mind.  The USNET source may
             be thought of as having components with different levels of
             hardware and compiler dependence.

                              +-------------------- +       
                               target-independent                              |                     |                                                    |
                               code                              |                              +-------------------- + 
                              +------- -----------  +                    
                               process    processo   hardware support                              |        |            |
                               or 1       r 2        8086, 68000, Z180                              |        |            |
                                                     etc                              |        |            |
                              |------- -----------  |                    
                               compile                 makefile etc.                              |                     |
                               r                     Borland, Microsoft                              |                     |
                                                     etc.                              |                     |
                              +------- ------------ +                    







             3             3             _ USNET User's Manual               ___________________









             2.   INSTALLING USNET             2.   INSTALLING USNET             _____________________
             --------------------------------------------------------------



             FOR DOS             FOR DOS

             To install USNET into the current directory, insert the
             diskette into drive x and type

                  x:install <target directory> <processor> <compiler>

             To get a list of available processors and compilers, just type
             "INSTALL", or check file README.TXT.  If your particular
             target is not supported, you can either install the closest
             relative, or copy the whole diskette using

                  xcopy a: <directory> /s


             FOR UNIX             FOR UNIX

             The details on how to read a DOS disk into a UNIX system vary,
             the following apply to a Sun workstation.  Set your current
             directory to where you want the files, insert the disk, mount
             it with

                    su
                    mount /pcfs
                    exit

             Then type

                    /pcfs/install /pcfs


             SIMPLE TEST             SIMPLE TEST

             USNET includes a simple local test program LTEST.  Running
             this is meant to be a part of the installation process.  This
             will only take a few minutes if everything is fine, and if
             everything is not fine you will want to know as early as
             possible.

             LTEST sends and receives messages locally, and tests various
             error situations.  It uses the USNET protocol stack, except
             that the driver is replaced with the pseudo-driver WRAP.  This
             is the output from a successful run, assuming that trace level
             is 0 or 1:

                  ***SEND AND RECEIVE 20 MESSAGES






               ---20 MESSAGES OK
               ***SEQUENCE NUMBER ROLLOVER
               ---ROLLOVER OK
               ***OUT OF ORDER MESSAGES
               ---OUT OF ORDER OK
               ***DUPLICATE MESSAGES
               ---DUPLICATE OK
               ***RETRANSMISSION
               ---RETRANSMISSION OK

               no errors in LTEST


          BUILDING LTEST          BUILDING LTEST

          Since USNET is supplied as sourcecode, you will need to build
          the test program before running it.  How this is done depends
          on whether USNET supports the processor and compiler you are
          using.  Building instructions are given below for 3 different
          cases.


          BOTH PROCESSOR AND COMPILER ARE SUPPORTED          BOTH PROCESSOR AND COMPILER ARE SUPPORTED          _________________________________________

          If USNET contains support files for your target processor and
          compiler building the test program is as follows:

           (1) Edit the makefile parameter PTH to give the directory
               path to your C compiler.

           (2) In some cases you have to replace the Nputchr() routine
               (in module PUTCHR or SUPPA) with your own version. This
               is discussed in chapter 3.

           (3) For an embedded system, you may have to change the load
               base address, given either in the makefile or in a linker
               parameter file.

           (4) Type "nmake ltest" or "make ltest" depending on the name
               of your make utility.

           (5) Load and run ltest.


          PROCESSOR SUPPORTED BUT NOT COMPILER          PROCESSOR SUPPORTED BUT NOT COMPILER          ____________________________________

          If there is support for your processor but not for your
          compiler, the steps will be:

          (1)  Create a compiler directory under the processor
               directory.  Copy all the files from an existing compiler
               directory.






             (2)  Edit the tool names and command line options in the
                  makefile.

             (3)  Check that any included assembly modules are suitable for
                  the new compiler.  For most embedded systems, LTEST needs
                  START (startup code), PUTCHR (character display), and
                  possibly SUPPA (miscellaneous low-level support).

             (4)  Proceed from point 2 of the first case above.


             NEITHER PROCESSOR OR COMPILER IS SUPPORTED             NEITHER PROCESSOR OR COMPILER IS SUPPORTED             __________________________________________

             If there is no direct support for your compiler and processor,
             proceed as follows:

             (1)  Create directories for the new processor and compiler.
                  Copy all the files from an existing processor/compiler
                  directory pair.

             (2)  Edit the makefile parameter ENDIAN to LITTLE (little-                                                        ______
                  endian or Intel-type addressing) or BIG (big-endian or                                                      ___
                  Motorola-type addressing).

             (3)  For segmented architectures such as the 8086 you also
                  need to add the parameter FARDEF to the compilation
                  flags.  See the 8086 support on how this is done.

             (4)  Proceed from point 2 of the first case above.


             DISPLAYING TRACE DATA             DISPLAYING TRACE DATA

             Within the makefile, a macro is defined which allows you to
             control the level of trace data output to the screen.  To
             change this, modify the NTRACE macro.  You may use any value
             from 0 through 9 with 0 representing no trace and increasing
             numbers representing an increasing amount of trace output.
             Interpretation of trace data is not covered in this manual.
             Traces are provided with USNET strictly for problem
             determination and are not designed as a debugging tool.









             3.   USNET CONFIGURATION MANAGER             3.   USNET CONFIGURATION MANAGER             ________________________________
             --------------------------------------------------------------

             There are a number of USNET configuration options you may
             select to facilitate USNET with your application.  The most
             important of these is the network configuration.  Configuring
             the network defines network connections to USNET including
             hostnames, portnames, internet (IP) addresses, network
             hardware, (Ethernet, SLIP, etc), and device drivers.  USNCFG
             is a DOS based program provided with USNET to assist with
             network configuration.

             To run USNCFG from a DOS prompt from the directory containing
             the USNET sourcecode.  For instance, if your current directory
             is the directory where you installed USNET

                  C:\USNET\>USNCFG

             An information box displays the hostname for the system.  This
             is taken from a PC environment variable HOST.  USNCFG informs
             when this variable is not set.  The HOST environment variable
             must be defined for USNET to run on the system.  In DOS this
             is done via the SET command and usually placed in the
             AUTOEXEC.BAT file.  To continue the configuration, press ENTER
             as directed.


             Main Screen             Main Screen

             On the main screen, each colored area represents a different
             window of information.  The gray title bar at the top shows
             commands and the keys to activate them.  The large cyan window
             in the center of the screen lists table entries for the
             network configuration table.  The bright green bar displays
             the column headings for the table.  You may scroll through the
             table entries using the arrow keys.  The currently selected
             entry is highlighted in black.  The bottom purple area
             displays errors in red when they occur and also shows all
             hosts on the same subnet as the currently selected host.
             Subnets will be explained in detail later in this chapter.


             Keys and Operations             Keys and Operations

             The gray title bar describes the keys for performing the
             various operations.  These are listed below.






               ESC            abort
               F9             sound, If on, beeps occur for errors and
                              invalid keystrokes.
               F10            save
               SPACE          toggle sort order
               ENTER          edit currently selected entry
               INS            add a new network record to the table
               DEL            delete a table record
               DOWN ARROW,    moves table record selection cursor.
               UP ARROW

          The record edit screen (see Editing and Modifying Table                                       __________________________
          Entries) has a different set of keys and commands from this          _______
          list.  It is similar though and should be self-explanatory
          after reading the section on Editing and Modifying Table
          Entries.


          Status Indicators          Status Indicators

          The gray title bar shows three status indicators.  The sorting
          order is displayed in brown in the upper left corner.  Note
          that table records also show hostname and internet addresses
          using the brown color.  This highlights the fields used for
          sorting the records.  On the far right hand side of the title
          bar are the cursor indicator and sound indicator.  The cursor
          indicator shows the currently selected record out of the totol
          number of records.  For instance, 3/5 shows the cursor is on
          the third record and there are five records total.  The sound
          indicator shows whether the sound toggle key (F9) is on or
          off.  When the sound indicator is on, errors and invalid
          keystrokes will cause a beep.


          Network Configuration Table          Network Configuration Table

          Each record in the network configuration table is displayed in
          two rows.  From left to right using row 1 first, the fields
          are

               host      hostname
               prt       portname
               T         subnet class
               Internet  internet address
               Ethernet  Ethernet hardware address
               Notes     misc options
               Net       network type, Ethernet, SLIP, etc
               Adpt      is there a PCMIA adapter present, if not, it's
               0.
               Driver    device driver






             Entering and Modifying Table Entries             Entering and Modifying Table Entries

             From the main screen, to enter a new entry press the INS key
             or to modify the currently selected entry simply press ENTER.
             You will then be shown the record edit screen.  Again the
             title bar shows the operations you may perform.  The cyan area
             displays the record you are currently editing.  Use the up and
             down arrows to move between fields.

             Some fields allow you to type a new entry or modify the
             existing one while others require you to select from a list of
             options.  The network mask, network type, adapter, and driver
             fields are selection fields.  Use the spacebar to circulate
             between the different options.  For network class, if you
             chose either A, B, or C the network mask is displayed as a hex
             number, however, if you choose the question mark the question
             mark for network class, you may then enter your own network
             mask.  The network mask field will display the correct value
             automatically as you select the network class (except in the
             case of the question mark value of course).  The device driver
             is another selection field and the string parameters required
             of the device driver are automatically displayed in the driver
             init field.  This entry is meant only as an example.  It shows
             the parameters required for the device driver however, the
             actual addresses and port numbers may not be correct.  You
             must edit the addresses port numbers and other fields to those
             which are correct for your system.


             Record Edit Window Keys and Commands             Record Edit Window Keys and Commands             ____________________________________

             ESC              return to main screen without saving entries.
             F9               sound--if on, beeps occur for errors and
                              invalid keystrokes.
             F10              save entry, return to main screen.
             ENTER            move to next entry.
             SPACE            toggles fields network class, network notes,
                              network type, adapter name, and driver name,
                              otherwise, enters a space character.
             TAB              move to next entry.
             CTRL-X           delete an entry.
             CTRL-R           restore previous entry.
             UP/DOWN arrow    moves cursor.



             Status Window             Status Window

             The purple window to the bottom of the main screen and the
             record edit screen is the status window.  Error messages are
             displayed here (to the right hand side) in red.  Also
             information is displayed showing the status of your subnets.
             A subnet is simply a network within a larger network and is






          defined by the values of the network class and the internet
          address.

          For example, for a class C network the first 3 numbers in an
          internet address would define the subnet and the last number
          defines the host.  So, IP addresses 9.113.201.2 and
          9.0113.201.3 would be on the same network but 9.113.202.2
          would be on a different network.  The records displayed in
          white within the status window show all hosts on the same
          subnet as the currently selected record.  This helps you view
          the current network configuration and will show you all hosts
          directly connected to the currently selected host.  Use this
          as a tool for spotting errors in your IP addresses.


          Error Messages          Error Messages

          ***>2 hosts on serial subnet:  You have a serial subnet with          ***>2 hosts on serial subnet
             more than two hosts connected to it.  Serial links only
             allow two hosts on a given subnet.

          *** Different Subnet Name:  Your portname (2nd field) is          *** Different Subnet Name
             different from the other portnames on this given subnet.
             This is for Ethernet connections.  Generally, as a
             convention, the portname should be the same for all hosts
             on an Ethernet network.

          *** Duplicate Host on Subnet:  A hostname was used twice          *** Duplicate Host on Subnet
             within the same subnet.  Hostnames must be unique within a
             subnet.

          *** Duplicate Internet Address:  The same internet address was          *** Duplicate Internet Address
             used twice.  Internet addresses must be unique.









             4.   CONFIGURING USNET             4.   CONFIGURING USNET             ______________________
             --------------------------------------------------------------



             OVERVIEW             OVERVIEW

             You may either use the Configuration Manager program to assist
             with configuration of your network or you may perform your
             configuration manually.  Either way, this chapter assists in
             understanding network configuration beyond that of the
             Configuration Manager.  Since the Configuration Manager only
             runs in a DOS environment, if you are configuring USNET on
             some other environment, you will need to edit the network
             configuration table by hand.  In addition, it is important to
             understand how your network operates.  For these reasons, this
             chapter provides an in depth look at network configuration.
             In addition, there are configurations other than the network
             configuration which an application may require that are not
             addressed by the Configuration Manager.  These additional
             configurations are also presented here.

             The primary configuration is the construction of the network
             configuration table.  This is the structure which defines the
             network to USNET.  This procedure is described in this chapter
             and several examples are provided.  Other configurations which
             may be needed are also described.  Here is a quick list of the
             various configurations that can be performed.

              (1) Makefile configuration.  This was explained previously in
                  the installation chapter.

              (2) Network configuration.  Module NETCONF.C contains a table
                  of all network connections.

              (3) Driver configuration.  Module DRVCONF.C defines the
                  drivers used in your application.  To use standard NDIS
                  drivers, you also need to edit some system files.

              (4) File LOCAL.H contains site-dependent definitions, such as
                  the various size parameters.

              (5) Multitasking support.  Header file SUPPORT.H has a set of
                  multitasking macros.  This is explained in the
                  multitasking section.

              (6) Writing new protocols is treated in section 10.






          NETWORK CONFIGURATION          NETWORK CONFIGURATION

          The initial network configuration table netdata is in module                                                  _______
          NETCONF.C.  This table provides information defining the
          network connections.  It contains one entry for each network
          connection you have.  In a simple network you would probably
          have one entry per host, however, you are allowed two or more
          entries for the same host, if for example, one host was
          connected to two different networks.  An example could be a
          host with an Ethernet connection and a serial connection.  In
          other words, you are not limited to one network per host.
          Each table entry describes a network controller on the
          network.

          This table must contain entries not only for the current host
          but also for all hosts this machine will be communicating
          with.

          A network structure contains the following fields:

          host name      String hostname of the computer.  The names          host name
                         must be unique.

          port name      String name of the port for the network          port name
                         controller.  The names must be unique within
                         one host.  For point to point connections, use
                         descriptive names such as "com1".  For real
                         networks, give a unique name to each network,
                         and use the same name for each connecting port.

                         If no Internet address is given, port name is
                         used to identify the network.

          address mask   Specifies which part of the internet address          address mask
                         specifies the host (zero bits) and which
                         specifies the network (one bits).  This is
                         sometimes called a subnet mask when a network
                         is divided into subnets.  For instance, the
                         mask for a class C network is
                         {0xff,0xff,0xff,0} which written in dotted
                         notation would be 255.255.255.0.  Generally, IP
                         networks use class A, class B, or class C
                         address masks.  The supplied #define constants
                         A, B, and C serve as abbreviations for these
                         standard address masks.

                         When two hosts have the same network address
                         (the part of the Internet address for which the
                         address mask is one), USNET assumes that they
                         can talk directly to each other.

          address        The network (internet) address of the          address
                         connection.  If zero, USNET will attempt to get
                         the address using RARP.







             hardware       The hardware address of the connection.  This             hardware
             address        is usually zero, symbol EA0 (it is defined as a             address
                            structure).  USNET will get local addresses
                            from the network controllers, remote addresses
                            using ARP.  You need to supply the address in
                            two cases:

                            (1) In a bootload server for any hosts that do
                                not know their own Internet address.

                            (2) For a local network controller that does
                                not know its own address.

             flags          Configuration flags:             flags          
                            NOTUSED     The connection becomes invisible.
                                        This is useful for configuring out
                                        a record without actually deleting
                                        it.
                            TIMESERVER  The host will respond to any time
             requests.
                            BOOTSERVER  The host runs a BOOTP server.

             link layer     The link level protocol which must be defined             link layer
                            in NET.H.  This is the name of the network,
                            such as Ethernet, or the name of a specific
                            low-level protocol, such as SLIP.  See file
                            README.TXT for supported data links.

             driver         The name of the device driver which must be             driver
                            defined in DRVCONF.H.  See file README.TXT for
                            a list of supplied drivers.

             adapter        The adapter will be initialized before the             adapter                                                            ______
                            driver, and shut off after the driver.  The                                                 _____
                            following files are included:

                              PCMCIA1  PCMCIA using card services
                              PCMCIA2  PCMCIA using socket services

                            You can create your own adapter module if you
                            need special initialization for a driver.  Use
                            the value 0 if there is no adapter.  The
                            adapter modules are defined in DRVCONF.H.

             parameters     This is a text string giving the hardware             parameters
                            parameters for the network controller.  The
                            information is only used in the driver and the
                            adapter initialization.  The supplied code uses
                            the following conventions:






                         IRNO=n    interrupt number, in some cases
                                   vector address
                         PORT=p    I/O address base
                         BUFFER=a  memory-mapped I/O base
                         BAUD=b    serial baud rate

                         To give a number in hexadecimal, use the prefix
                         0x as in 0x2ef.

          Examples          ________

          Here is an example of an Ethernet configuration entry:

                "hostX", "enet", C, {192,9,201,4}, EA0, 0, Ethernet,
                    WD8003, 0, "IRNO=3, PORT=0x280, BUFFER=0xd0000",

          HostX is connected to a network via a port called "enet" which
          uses the class C address mask.  The four numbers within wave
          brackets are the Internet address (for class C, the first 3
          numbers identify the network, the fourth the host itself). The
          hardware address is EA0.  No flag bits are used.  The link
          layer is Ethernet, the driver is WD8003 (file WD8003.C).
          There is no adapter.  The parameter string gives the interrupt
          number, the port address, and the shared buffer address.

          A serial port might be as follows:

                "hostX", "com2", C, {192,9,202,4}, EA0, 0, SLIP, I8250,
                    0, "IRNO=4, PORT=0x3f8, BAUD=38400",

          This defines hostX connected to a network via a port it refers
          to as "com2".  It was useful to think of it as a com port (PC
          terminology) since that was the port used by the serial
          interface card.  This field is strictly a string identifier.
          Naming it com2 is a convention.  Whether it really is the com2
          port depends on the interrupt number and port address used.
          Network class, internet number, hardware address, and the
          flags are defined and used exactly as for Ethernet.  The link
          protocol is SLIP, the driver is I8250, no adapter is used.
          The parameter string gives the interrupt number, the port
          address and the baud rate.  Be sure these values are correct
          for your hardware configuration or the connection will not
          work.

          This example shows a complete table with multiple entries.
          You can see it is coded as a standard C struct:






               const struct NETDATA netdata[]={
                  "test1", "nnet", C, {192,9,201,1}, EA0, 0, Ethernet,
                  NE2000, 0, "IRNO=5  PORT=0x300",
                  "test1", "com2", C, {192,9,202,1}, EA0, 0, SLIP, I8250,
                    0, "IRNO=3 PORT=0x2f8  CLOCK=115200 BAUD=38400",
                  "test1", "tnet", C, {192,9,203,1}, EA0, 0, Ethernet,
                  EXP16, 0, "IRNO=4   PORT=0x340",
                  "test2", "nnet", C, {192,9,201,2}, EA0, 0, Ethernet,
                    WD8003, 0, "IRNO=5 PORT=0x300    BUFFER=0xca000",
                  "test3", "com4", C, {192,9,202,2}, EA0, 0, SLIP, I8250,
                    0, "IRNO=3 PORT=0x2e8  CLOCK=115200 BAUD=38400",
                  "test4", "tnet", C, {192,9,203,2}, EA0, 0, Ethernet,
                  NE2000, 0, "IRNO=10      PORT=0x320",
                  "sun", "tnet", C, {192,9,203,3}, EA0, 0, 0, 0, 0, 0,
               };

             Host "test1" has multiple entries defining different networks,
             two Ethernet, and one serial, with the Ethernet connections
             using different controllers (note each Ethernet record has a
             different port address and interrupt number).  Test1 is
             connected to three different networks and can communicate with
             test2 via "nnet", test3 via "com2", and test4 or the sun
             workstation via "tnet".  Note that the internet number is what
             uniquely defines the network.  The nnet network is defined by
             the internet addresses 192,9,201,x where x defines the                                                      _
             specific host.

             In the case of the serial connection the portname is different
             for test1 and test2, however, the Ethernet connections all use
             the same portname for a given network.  The point here is to
             uniquely define a port for a given host.  The example above
             shows two conventions, The Ethernet examples name it as a name
             for the network; the serial connection names it according to
             the port used for the connection.  Use whichever is useful to
             your application.

             This next example shows tables on different hosts required for
             the two hosts to communicate via Ethernet:

               Host1:
                   "host1", "nnet", C, {192,9,201,2}, EA0, 0, Ethernet,
               NE2000, 0, "IRNO=5 PORT=0x300",
                   "host2", "nnet", C, {192,9,201,3}, EA0, 0, Ethernet,
               NE2000, 0, "IRNO=5 PORT=0x300",

               Host2:

                   "host1", "nnet", C, {192,9,201,2}, EA0, 0, Ethernet,
               NE2000, 0, "IRNO=5 PORT=0x300",
                   "host2", "nnet", C, {192,9,201,3}, EA0, 0, Ethernet,
               NE2000, 0, "IRNO=5 PORT=0x300",






          You can see both tables are identical.  Distinguishing between
          the local and remote host is not a function of the network
          configuration table.

          Also, each table entry is the same aside from the IP
          addresses.  The interrupts and port numbers are identical, but
          they do not have to be.  That depends on your hardware
          configuration.

          An example showing serial links would be similar:

            Host1:
                "host1", "com2", C, {192,9,202,2}, EA0, 0, SLIP, I8250,
            0, "IRNO=3 PORT=0x2f8 CLOCK=115200 BAUD=38400",
                "host2", "com4", C, {192,9,202,3}, EA0, 0, SLIP, I8250,
            0, "IRNO=3 PORT=0x2e8 CLOCK=115200 BAUD=38400",

            Host2:
                "host1", "com2", C, {192,9,202,2}, EA0, 0, SLIP, I8250,
            0, "IRNO=3 PORT=0x2f8 CLOCK=115200 BAUD=38400",
                "host2", "com4", C, {192,9,202,3}, EA0, 0, SLIP, I8250,
            0, "IRNO=3 PORT=0x2e8 CLOCK=115200 BAUD=38400",

          Note host1 and host2 use different ports.  Again, the portname
          field is not a network name; both of these hosts are defined
          on the same network (via the internet numbers), the 2nd field
          simply is used to uniquely define a network controller on a
          given host.  Also, notice the port addresses in the driver
          parameter string are different which is required by the
          different com ports.


          TIMER SUPPORT          TIMER SUPPORT

          USNET is shipped with ready-to-go timer routines which operate
          on a given hardware platform.  In most cases this should be
          sufficient, however, if your embedded system requires the use
          of an unsupported timer chip, you may support this by
          replacing the timer routines with your own.  The USNET timer
          routines are described here to assist with that process.

          USNET uses time values expressed in milliseconds.  It does not
          need timer interrupts, just a tick count and a clock
          frequency.  In DOS and UNIX environments, USNET takes these
          values from the ANSI C services.  In embedded environments,
          USNET sets up a hardware clock.

          USNET low-level support for each processor contains the
          following clock routines:






              (1) Nclk_init() to set up the clock
              (2) Nclk_term() to turn off the clock                  
              (3) clock() to return number of clock ticks as a 32-bit                  
             integer

             These are in CLOCK.C or in SUPPA.ASM depending on which
             hardware platform you installed.  Each works for some
             particular test board; in some cases, several versions are
             included.  You will quite possibly need to modify the code to
             fit your hardware.  The clock frequency is stored into the
             variable clocks_per_sec.                      ______________

             The low-level clock routines are called from the macros
             LOCALSETUP() and LOCALSHUTOFF().  The clock frequency is also                          
             stored in LOCALSETUP().  (It would be more natural to store in
             Nclkinit(), but this is often in assembly code, and in some
             cases not used.)  These macros are defined in LOCAL.H and are
             as follows:

                 extern unsigned int clocks_per_sec;
                 #define LOCALSETUP() 0, clocks_per_sec = 100, Nclkinit()
                 #define LOCALSHUTOFF() Nclkterm()

             The number 0 that starts LOCALSETUP() is simply the return
             code in this case.

             If you can use the ANSI C clock support, you do not need the
             low-level clock routines Nclkinit(), Nclkterm() or clock() at
             all.  Just set the clock frequency in the LOCALSETUP() macro,
             for instance:

                 #include <time.h>
                 extern unsigned int clocks_per_sec;
                 #define LOCALSETUP() 0, clocks_per_sec = (unsigned
               int)CLOCKS_PER_SEC
                 #define LOCALSHUTOFF()

             Most multitasking operating systems handle timekeeping
             functions.  For these, define clock() to return the number of
             ticks as a long integer, and LOCALSETUP() to store the clock
             frequency into clocks_per_sec.                            ______________


             DISPLAY AND KEYBOARD SUPPORT             DISPLAY AND KEYBOARD SUPPORT

             USNET provides a function, Nputchr(), for displaying
             characters to a display device.  You may replace this with
             your own if required by your application or hardware platform.

             The application level and the trace feature of USNET use
             Nputchr() when displaying characters.  The routine is either
             in C in file PUTCHR.C, or in assembler in file SUPPA.ASM
             depending on how USNET was installed.  In DOS and UNIX






          environments, the C code calls directly the ANSI C function
          putchar().


          HOSTNAME          HOSTNAME

          USNET must know its own host name.  This is obtained using the
          macro HOSTNAME(), defined in LOCAL.H.  For DOS and UNIX
          environments, the macro gets the name using the ANSI C
          function getenv.  In these cases, the name would be defined
          with set host=myhostname".               ___________________

          For embedded targets, the supplied HOSTNAME() loads a fixed
          name.  You will want to keep the hostnames unique within a
          network as you would on any network to avoid ambiguities.
          There is no absolute rule against duplicate names, however
          there may be consequences.  For instance, host XXX cannot open
          by name another host called XXX, or if a network had a host
          YYY and two hosts XXX, YYY would communicate with the XXX
          listed first in the network configuration table and the second
          XXX could not be reached in this manner.  All XXX hosts,
          however, could still talk to host YYY.  Unless you have some
          special needs, it is best to keep your hostnames unique.

          If you have a network with a large number of identical hosts,
          you may want to supply your own HOSTNAME() macro.  This could
          get the name from an EPROM or a similar source.  It could also
          read an identification off a network controller and match this
          to a table.  This method of course requires that all hosts
          have an identical hardware configuration.

          File LOCAL.H also contains a userid USERID and a password
          PASSWD.  These are used for connecting to an FTP server.  The
          supplied FTP server does not require a userid or a password.


          PROTOCOL SUPPORT          PROTOCOL SUPPORT

          File NET.H defines the protocols (including the link layer,
          but not the drivers) known to USNET.  Any that you do not need
          you can take out with the #undef statement in the local
          configuration file LOCAL.H.  The following is an example of
          how this is done:

            #undef UDP          /* --- not needed --- */

          Section 10 describes how to add new protocols to USNET.


          DRIVER SUPPORT          DRIVER SUPPORT

          All drivers referenced by the network configuration table in
          NETCONF.C need to be defined to USNET, however only those
          required by the local system need to be compiled and linked






             into the executable.  Therefore, some drivers will be defined
             to the system but will not be linked in.

             Drivers are defined in DRVCONF.H.  All drivers referenced in
             the network configuration table need to be defined here.
             Drivers used in netconf.c that will not be linked in are
             defined as 0.  An example is shown here.  Note, the wrap                                                                 ____
             driver is used to have a host communicate with itself.  This
             is a feature used by the test program LTEST.

               #define wrap &wrap_T   /* to talk to self, for testing */
               extern PTABLE wrap_T;

               #define WD8003 &WD8003_T /* Western Digital Ethernet board
               */
               extern PTABLE WD8003_T;

               #define NE2000 &NE2000_T /* Novell 2000 Ethernet interface
               */
               extern PTABLE NE2000_T;

               #define EN360 0        /* Motorola 68360 Ethernet */

               #define I8250 &I8250_T      /* PC serial ports */
               extern PTABLE I8250_T;

               #define H64180 0       /* Hitachi 64180 on-chip serial */

               #define HC11SCI 0      /* Motorola HC11 on-chip serial */

               #define HC16SCI 0      /* Motorola HC16 on-chip serial */

               #define D2681 0        /* DUART 681 serial */


             USNET can also use standard NDIS drivers.  NDIS is a network
             driver standard developed by 3Com and Microsoft for DOS and
             OS/2.  NDIS drivers (in binary format) are often available
             from the board manufacturer.  To configure one of these,
             proceed as follows:

              (1) Configure the NDIS driver as instructed by the supplier.
                  (You can get the NDIS documentation and utilities from
                  3Com.)

              (2) Specify NDIS as the driver in NETCONF.C.

              (3) Edit file PROTOCOL.INI (this is an NDIS system file, not
                  a USNET file) to add the definition:






                    USNET NDIS resident stub is configured here
                    ;
                    [USNETDRV]
                      DRIVERNAME=USNET$
                      BINDINGS=drivername

               where drivername is the NDIS driver you want to use.                     __________

          (4)       Add to CONFIG.SYS the line

                    device=path/usnet.dos

               where path is the directory where you have the USNET                     ____
          files.

           (5) Build USNET.DOS with the command make usnet.dos.  You can                                                ______________
               do this at any time; configuration operations should not
               affect the usnet.dos driver.


          LOCAL PARAMETERS          LOCAL PARAMETERS

          File LOCAL.H configures the following parameters:

          MAXBUF           The size of message buffers: largest user-          MAXBUF
                           level message plus protocol headers plus the
                           internal header MESSH (defined in file
                           NET.H).  The most common header sizes are:

                              MESSH: 10 bytes if pointer is 2 bytes, 14
                              bytes otherwise
                              link layer: 14 bytes
                              TCP: 20 bytes
                              UDP: 8 bytes
                              IP: 20 bytes

                           An Ethernet message can be up to 1514 bytes
                           long, so MAXBUF 1528 is usually safe,
                           allowing 14 bytes for MESSH.  Serial lines
                           typically use 512-byte blocking, for a MAXBUF
                           of 540.

                           The size of MESSH depends on the number of
                           bytes allowed for pointers by the compiler.
                           This varies depending on factors such as the
                           processor used or the memory model used for
                           compiling.

                           Beware of DMA though!  USNET reserves
                           internally an extra 4 bytes after a message
                           buffer, because DMA typically moves the CRC
                           into memory.  However, some hardware moves
                           more than this, and you have to increase






                              MAXBUF accordingly.  See the driver list in
                              README.TXT for information.

             NNETS            Maximum number of network controllers in one             NNETS
                              host.

             NCONNS           Maximum number of open logical connections in             NCONNS
                              one host.

             NBUFFS           Number of message buffers.  How many you need             NBUFFS
                              depends very much on your application and
                              your network load.  A worst-case calculation
                              might be 5 per active network, plus 3 per
                              active connection or socket.  For example:

                                 NBUFFS = 5 x NNETS + 3 x NCONNS

             FRAGMENTATION    If defined, the code to fragment and to             FRAGMENTATION
                              reassemble messages (principally in IP.C) is
                              included during compilation.









             5.   USER INTERFACE             5.   USER INTERFACE             ___________________
             --------------------------------------------------------------



             INCLUDE FILES             INCLUDE FILES

             All programs that call USNET routines need to contain the
             following include statement:

                  "#include "net.h

             An application that uses the ICMP protocol directly needs

                  #include "net.h"
                  #include "icmp.h"



             INITIALIZATION             INITIALIZATION

             Before you can use any USNET functions, you need to initialize
             the software and the network controllers.  This is done with
             the function


             int Ninit()             int Ninit()             ___________

             Ninit() has no parameters.

             The return value is either 0, or a negative error code of

               NE_NOBUFS    No buffers available.

             Example:             _______

               main()
               {
               ....
                  /* initialize all connections */
                  if (Ninit() < 0)                      Ninit()
                     << process error >>
               ....
               }

             The corresponding shutdown function is






          int Nterm()          int Nterm()          ___________

          where again, there is no argument.  The shutdown is
          reversible, just do another Ninit().


          Example:          ________

            /* shutdown all network connections */
            Nterm();            Nterm();

          The communication ports must also be initialized.  This is
          performed with


          int Portinit(char *name)          int Portinit(char *name)          ________________________

          If name is "*", all ports defined in the network configuration                               ____
          table are initialized, otherwise only the portname name is                                                             ____
          initialized.  (Portname is taken from the second field in the
          network configuration table in NETCONF.C.)  This means for
          instance that if you have an Ethernet controller and a serial
          port, you can initialize the serial port without touching the
          Ethernet, and vice versa.

          The return value is either 0 for success or an error value <
          0.  The error codes are

          NE_PARAML      Parameter error, the driver did not accept the
                         initialization text in table netconf.                                                      _______

          NE_NOTCONF     The specified port (when "*" is not used) is
                         not in netconf for this host.  This could also                                _______
                         mean that the host name is wrong.

          NE_HWERR       A hardware error occured.  Generally, this
                         indicates an error with the network controller.

          Examples:          ________

            main()
            {
            ....
               if (Ninit() < 0)
               ...<< process error >>
               if (Portinit("*") < 0)                   Portinit("*")
               ...<< process error >>
            ....
            }






             or, if initializing a specific port

               main()
               {
               ....
                  if (Ninit() < 0)
                  ...<< process error >>
                  if (Portinit("com1") < 0)                      Portinit("com1")
                  ...<< process error >>
               ....
               }

             The corresponding shutdown function is


             int Portterm()             int Portterm()             ______________

             where there is no argument.  The shutdown is reversible, just
             do another Portinit().


             Examples:             ________

               /* shutdown all network connections */
               Portterm("*");               Portterm("*");

               or

               /* shutdown a specific network connection */
               Portterm("com1");               Portterm("com1");


             CONNECTIONS             CONNECTIONS

             Connections behave very much like files: you can open and
             close a connection, you can read data from it, and write data
             to it.  The main difference is that a connection has a user at
             each end, a file has only one user.  The data you read is the
             data the other user wrote, and vice versa.

             USNET offers the user two basic kinds of connections: TCP and
             UDP connections.  The difference is that TCP performs error
             correction and flow control, UDP does not.  You can read TCP
             like a local disk file: you want to check for errors, but they
             should not occur and if they do you quit.  Doing this with UDP
             would be foolhardy, and writing applications using UDP is
             quite cumbersome.  You should leave UDP for pre-written
             applications, such as TFTP and BOOTP.


             OPEN, CLOSE, READ, WRITE             OPEN, CLOSE, READ, WRITE

             These four routines (plus the startup and shutdown) are the
             only user-level network functions in USNET.  This might             ____






          surprise you, especially if you have seen network packages
          that go something like

               call TCPwrite
               call IPwrite
               call DRIVERwrite

          and so on.  USNET uses a table-driven protocol stack
          structure.  Each protocol level has only one public symbol:
          the name of the protocol table.  USNET performs all necessary
          calls through these protocol tables.  The user only has to
          call a general high-level function that is the same for all
          protocol configurations.

          The open function specifies which protocols, and in which
          order, are to be used.  There are no restrictions on the
          protocol stack as such, but of course not all combinations
          make sense.


          int Nopen(char *to, char *protoc, int p1, int p2, int flags)          int Nopen(char *to, char *protoc, int p1, int p2, int flags)          ____________________________________________________________

          This function opens a connection.  The arguments are:

          to      Name of the target host.  You can also use form          to
                  "port/host" where port is a local network name, or "*"
                  to mean any.

          protoc  Protocol stack.  This is a list of the protocols,          protoc  
                  separated by slashes.  The link level and the driver
                  are not included.  Normally the stack would be
                  "TCP/IP" or "UDP/IP", perhaps also "ICMP/IP".

          p1, p2  Local and remote port number.  Port numbers are used          p1, p2
                  to match the two ends of the connection.  If your
                  local port is my remote port and vice versa, then we
                  have a connection.  Normally one end uses an active                                                               ______
                  open and the other a passive open.  The passive open                                       _______
                  is done with p2 zero and parameter to "*".  It sits                                                                                    __                    __
                  and waits until it gets a message from an active open.
                  In other words, a passive open is how a server would
                  operate.

                  Port numbers (except those with a fixed meaning)
                  should not be reused immediately.  Many systems have a
                  considerable delay time before processing a
                  disconnect.  If a reconnect was issued to the same
                  port number, the connection may be refused.  Use
                  subroutine portno() to obtain random port numbers.                             

          flags   The timeout for a passive open is defined as          flags   
                  TOUT_PASSIVE in net.h, shipped as 1000 seconds.  The
                  timeout for an active open is meaningful only for TCP;






                     this sets it to about 10 seconds, depending on the
                     link type.

             If the connection succeeds, Nopen() returns with the
             connection number.  If the return is negative, there has been
             an error:

             NE_NOTCONF     Could not access the other host.

             NE_PROTO            Could not understand the other host.

             NE_TIMEOUT     Timeout.

             Examples:             ________

             A TCP connection would start like this:

               host1:  
                  int conno;      /* connection number */
                    ....
                    /* open connection to host2, use TCP/IP, local port
               1010 */
                  /* remote port 1000, no flags
               */
                  conno = Nopen("host2", "TCP/IP", 1010, 1000, 0);                  conno = Nopen("host2", "TCP/IP", 1010, 1000, 0);
                  if (conno < 0)
                       << process error >>

               host2:  
                  int conno;      /* connection number */
                    ....
                  /* open passive connection, use TCP/IP, local port 1000
               */
                  conno = Nopen("*", "TCP/IP", 1000, 0, 0);                  conno = Nopen("*", "TCP/IP", 1000, 0, 0);
                  if (conno < 0)
                       << process error >>


             The first of these is an active open, and causes TCP to send
             out open requests.  The open in host2 is passive, and accepts
             calls from anyone who asks for port number 1000.

             A UDP open for host1 through port com1 would look like this:

               host1:  conno = Nopen("com1/host2", "UDP/IP", 1000, 1010,
               0);

             The port "com1" is a host1 port, not a host2 port.  This form
             of open may be needed if there are two connections between
             host1 and host2.  In this manner, "com1" serves to identify
             which connection is being opened.  Note the "com1" references
             field 2 in the network configuration file in NETCONF.C.






          To send and receive ICMP messages, you can use the form:

            host1:  conno = Nopen("host2", "ICMP/IP", 1000, 1010, 0);

          This is a special situation; see, for instance, PING.C for the
          use of ICMP.  The host2 connection is, again, the same.


          int Nclose(int conno)          int Nclose(int conno)          _____________________

          This closes the connection number conno.  It waits until the                                            _____
          connection tables have been cleaned up.  The return is zero,
          or an error code:

          NE_TIMEOUT     Timeout.  The connection is closed at this end,
                         but the other end may not be clean.

          NE_PROTO       Protocol problem.  If you have been writing
                         data to the other host, consider the data
                         unsafe.

          Example:          _______

               int error;     /* error code        */
               int conno;     /* connection number */

               error = Nclose(conno);   /* close the connection */               error = Nclose(conno);   /* close the connection */
               if (error < 0)
                    << process error >>


          int Nread(int conno, char *buff, int len)          int Nread(int conno, char *buff, int len)          _________________________________________

          Read a message from connection conno into buff, maximum size                                         _____      ____
          len bytes.  The timeout value, in milliseconds, is in          ___
          connblo[conno].rxtout.  The return value equals number of          _____________________
          characters returned, or a negative error number:

          NE_TIMEOUT     Timeout.

          NE_PROTO       Protocol problem.






             Example:             _______

                  /* user defined input buffer size */
                  #define MAX_BUFFER_SIZE 80  ....
                  ....
                  int error;                      /* error code        */
                  int conno;                      /* connection number */
                  char buff[MAX_BUFFER_SIZE];     /* data input buffer */
                  ....
                  /* read data into "buff" from connection number "conno"
               */
                  error = Nread(conno, buff, sizeof(buff));                  error = Nread(conno, buff, sizeof(buff));
                  if (error < 0)
                       << process error >>;
               

             The constant MAX_BUFFER_SIZE could be replaced with the USNET
             constant MAXBUF defined in file LOCAL.H.


             int Nwrite(int conno, char *buff, int len)             int Nwrite(int conno, char *buff, int len)             __________________________________________

             Write a message at buff, size len bytes, to connection conno.                                ____       ___                      _____
             A negative return value means failure:

             NE_TIMEOUT     Timeout.  With TCP, this probably means that
                            the other end did not send acknowledgments
                            properly.  It could also mean an extremely
                            heavy system load and that a timeout occurred
                            before the acknowledgment could be received.

             NE_PROTO       Protocol problem.

             NE_HWERR       A hardware error occured.  Generally, this
                            indicates an error with the network controller.

             Example:             _______

                  /* user defined input buffer size */
                  #define MAX_BUFFER_SIZE 80  ....
                  ....
                  int error;                        /* error code */
                  int conno;                        /* connection number */
                  char buff[MAX_BUFFER_SIZE];       /* data input buffer */
                       ....
                  /* write data stored in "buff" to open connection "conno"
               */
                  error = Nwrite(conno, buff, sizeof(buff));                  error = Nwrite(conno, buff, sizeof(buff));
                  if (error < 0)
                       << process error >>

             Again, MAXBUF may be used in place of MAX_BUFFER_SIZE.






          Nwrite does not do stream I/O, so the maximum data length is
          the buffer size MAXBUF minus the necessary header sizes.  The
          exact value is in connblo[conno].maxdat (see the section on                            _____________________
          connblo[conno] below).          ______________

          Any possible errors for the last few writes may be reported in
          the Nclose function.  In networking, you should always check                                                          ______
          the close status.


          connblo[conno]          connblo[conno]          ______________

          The connection block may be used along with the connection
          number for some useful tests.  The connection block is an
          array of data structures which records information on open
          connections.  The connection number returned from Nopen() may
          be used as an index to the appropriate record.  For instance,
          to test if a message has arrived at the connection, test
          connblo[conno].first for non-zero.          ____________________

               if (connblo[conno].first)                   connblo[conno].first
                   << THERE IS A MESSAGE >>;

          This is just one example, and in most applications this test
          should not be needed since Nread() will halt and continue
          execution whenever a new message arrives.  Nevertheless, this
          example may still be useful for some applications.

          To test if the connection has been closed by the remote host,
          test for the EOF bit in the receive status:

               if (connblo[conno].rxflags & S_EOF)                   connblo[conno].rxflags
                   << CONNECTION IS CLOSED >>;


          OTHER USEFUL EXAMPLES          OTHER USEFUL EXAMPLES



          Broadcasting          Broadcasting          ____________

          For broadcasting messages to all hosts on the network, you use
          host name "*" in the active open, and then, do an Nwrite().
          For instance:

            host1:  conno = Nopen("enet/*", "UDP/IP", 1010, 1000, 0);
                    .....
                    stat = Nwrite(conno, buf, len);

          In this case, "enet" is the portname for the network, and "*"
          represents all hosts.  The receiving hosts' open() would
          generally be a passive open.






               host2:  conno = Nopen("*", "UDP/IP", 1000, 0, 0);
                       ....
                       stat = Nread(conno, buf, len);

             The receiving hosts must be listening on the same port number
             that the broadcasting host is sending to (i.e. 1000 in this
             case).

             Broadcasting should only be used for data links that support
             it in hardware, such as Ethernet.  It should not be done at
             the TCP level.

             If the broadcasting host connects to several networks, the
             open call must specify the network name.  Broadcasting is done                       ____
             to one network only.


             TCP File Transfer             TCP File Transfer             _________________

             This example might be used to write a file to a remote host.
             Flow control and error checking are handled by TCP.

                  conno = Nopen("host2", "TCP/IP", 1001, 1000, 0);
                  if (conno < 0)  << process error >>
                  for (;;)
                  {
                      len = fread(ifile, buf, sizeof(buf));
                      if (len <= 0) break;
                      stat = Nwrite(conno, buf, len);
                      if (stat < 0)  << process error >>
                  }
                  stat = Nclose(conno);
                  if (stat < 0)  << process error >>

             The other side of the connection might run as follows:

                  conno = Nopen("host1", "TCP/IP", 1000, 0, 0);
                  if (conno < 0)  << process error >>
                  for (;;)
                  {
                      len = Nread(conno, buf, sizeof(buf));
                      if (len < 0)  << process error >>
                      if (len == 0) break;
                      stat = fwrite(ofile, buf, len);
                      if (stat < 0)  << process error >>
                  }
                  stat = Nclose(conno);
                  if (stat < 0)  << process error >>









             6.   MULTITASKING             6.   MULTITASKING             _________________
             --------------------------------------------------------------

             Several macros are provided with USNET to support
             multitasking.  USNET, however, will operate with or without a
             multitasker.  In a single tasking environment, it performs
             internal tasking to handle timeouts and incoming messages, and
             can use several connections in parallel (by using multiple
             Nopens within an application).  However, to run several
             servers or a server and a client in the same host requires the
             use of a multitasking environment.

             The multitasking macros are contained in file SUPPORT.H.
             Parameter MT in LOCAL.H specifies the type of multitasking:

               0   none (internal tasking by polling)
               1   US Software MultiTask!
               2   any other multitaskers

             Set this parameter before you build USNET.  If using your own
             multitasking system, you will also need to rewrite the macros
             defined in this chapter to call the multitasking services of
             your environment.

             The functions needed are few and simple, and just about any
             multitasker should do.  USNET does not require pre-emptive
             task switching or task priorities.  The macros are explained
             in detail below.  Differences between single and multitasking
             environments are also described.


             TASK CREATION             TASK CREATION

             The macro

                  RUNTASK(func, prior, mp)

             is used to create and start a task using entry address func,                                                                    ____
             task priority prior and argument (a pointer) mp.                           _____                          __

             If task priorities are not supported, just ignore this field.
             If they are, you need to check that the three macros

               SERV_PRIOR   priority for servers
               CLIENT_PRIOR priority for client tasks
               NET_PRIOR    priority for the network task
                            (handling of arrived messages)

             have a reasonable value.  These are defined in SUPPORT.H.
             Make all these the same, unless you have a specific reason for
             doing otherwise.  Never make NET_PRIOR lower than the other






          two, or lower than your regular application priorities.  The
          system should be able to process incoming and outgoing network
          messages before application processes are ready to send or
          receive them.

          The pointer argument is essential to handle the FTP and TFTP
          servers properly.  If your multitasker does not support it,
          you can pass it to the task through a table indexed by task
          number.

          The definition TASKFUNCTION is the function type for your
          tasks.  If the operating system has no special requirements
          for this, make it void.  MultiTask! for instance expects all                            ____
          tasks to be void FAR.                      ________

          USNET assumes that a task main-level return terminates a task.
          If this is not true in your multitasking system, you need to
          add a task termination call to the end of the FTP and TFTP
          tasks.


          YIELDING CONTROL          YIELDING CONTROL

          The function YIELD() may be used to allow other tasks an
          opportunity to execute.  YIELD() is called internally from the
          "write message" function, to insure the network task (the task
          that processes arrived messages) gets a chance to execute.  If
          you use pre-emptive scheduling, you can leave YIELD() empty
          since task switching should do this for you.

          In some multitaskers, there is no simple way to give up
          control from a high-priority task, so doing a YIELD() in this
          case could be a problem.  As you should never give the network
          task a low priority (see above), this should not be a problem.


          PRE-EMPTION          PRE-EMPTION

          USNET calls the function BLOCKPREE() to block pre-emption, and
          RESUMEPREE() to restore it.  If there is no pre-emption, these
          macros are empty.

          In some cases, the best way to implement these functions is by
          disabling and enabling interrupts.  The blocking is never done
          for long periods of time, and never over an operating system
          function.


          SIGNALING          SIGNALING

          USNET relies on the following macros for interprocess
          communication.

            WAITFOR(condition, signo, msecs, flag)







             This waits for condition to become true, with the timeout                            _________
             msecs.  The condition is any standard C language condition             _____
             statement; msecs is an integer value representing the number
             of milliseconds until the wait times out.  Flag is a return                                                        ____
             value.  Signo assigns an identifying integer to the WAITFOR().                     _____

               WAITNOMORE(signo)
               WAITNOMORE_IR(signo)  (in interrupt handlers)

             WAITFOR() is called from a task and causes that task to wait
             until a condition is met. WAITNOMORE() is called from a
             separate task to cause the condition to be retested.  When
             WAITFOR() is called, execution halts temporarily at that
             point.  It returns a value where success indicates the signal
             event condition occurred.  If the wait times out, it returns a                   _________
             value indicating failed.  Both of these conditions should be
             tested since generally execution will be different depending
             on the outcome.

             In a non-multitasking system these may still be used.
             WAITFOR() may be used to wait until an incoming message is
             received and WAITNOMORE() is essentially a null macro (which
             could be placed within the application for portability issues
             between single and multitasking systems for example).

             The argument signo (signal number) ties these two functions                          _____
             together.  Below are the rules for the behavior of WAITFOR()
             and WAITNOMORE():

               (1)  If condition is true, WAITFOR() clears the flag and                       _________
                    returns.

               (2)  If condition is not true, WAITFOR() will delay up to                       _________
                    msec milliseconds.  During this time, each WAITNOMORE()                    ____
                    for signo causes WAITFOR to retest the condition.                        _____

               (3)  If the WAITFOR() implementation has a blind spot (see                                                          __________
                    examples below), the macro must accommodate lost
                    signals by retesting the condition after time is up.

               (4)  If the condition never became true, WAITFOR() returns
                    with flag set to any non-zero value.  In other words,                         ____
                    after processing resumes, flag is used for determining
                    whether WAITFOR() timed out or exited due to the
                    condition being met.

               (5)  Several tasks can be waiting for the same signal (same
                    signo), but only in the ARP and RARP protocols.
                    Preferably a WAITNOMORE should wake all of them up, but
                    a failure to do this is not fatal.

               (6)  The WAITNOMORE() is issued by one task only.






            (7)  The signal numbers go from 0 to 2*(NCONNS+NNETS) being
                 computed from the maximum number of connections and the
                 maximum number of networks.  The numbers are expressed
                 as macros, so you can change them fairly easily if
                 necessary.  This is also in SUPPORT.H.


          Please note that USNET does not expect your operating system
          to provide anything like the above WAITFOR() capability.  You
          need to create the WAITFOR() yourself with the multitasking
          functions available to you.  As a matter of fact, WAITFOR() is
          not necessarily tied to multitasking at all.  The single
          tasking version of WAITFOR() is simply

               for (flag=0,endtime=TimeMS()+msec; !(condition); )
               {
                   if (TimeMS() >= endtime)
                   {
                       flag = 1;
                       break;
                   }
                   YIELD();
               }

          In a multitasking environment, the condition would be retested
          each time a task called WAITNOMORE(); however, there is no
          other task in a system without multitasking, therefore, the
          condition is tested periodically within this loop.  The call
          to YIELD() can cause the condition to change causing the loop
          to break.  TimeMS() is a USNET support function which returns
          a network synchronized base time; the call within the "for"
          statement is simply used to get the starting time of the
          WAITFOR(), which, when added to msec, gives the time when the
          wait will timeout.

          As mentioned already, the signaling macros require signaling
          support to be provided by the multitasking system.  You may
          then, rewrite these macros to include the system calls
          provided by your system.  You can use semaphores to implement                                                __________
          the needed signaling.  These are present in almost all
          operating systems, defined in different ways, and often called
          events, counters, or resources.  In all cases, you can wait          ________________     _________
          for the semaphore (or event etc.) to be set, and you can set
          and clear the semaphore.

          Setting the semaphore will in some cases wake up all the
          waiting tasks, in some cases only one.  Some systems use the
          word event for the former and semaphore for the latter               _____                    _________
          feature, but this is not universal by any means.  USNET
          assumes that signaling wakes up all tasks, but will manage
          even if this does not happen.

          A semaphore has to be reset (cleared) at some point, otherwise
          no actual waiting will be done.  In some cases the semaphore






             (or event etc.) is cleared automatically by the multitasking
             system within either the waiting operation or the sending
             operation.  In many cases it is cleared by a separate
             operating system call, either in the signaling task or in the
             waiting task.  USNET does not really care which method is
             used.

             Here is a pseudocode example using generic system calls wait()
             and set_semaphore() which would be replaced by the
             multitasking system's actual system calls.  In the following
             discussion, execution will wait until the semaphore is set and
             will continue when it is cleared.  We will also assume in this
             multitasking system all tasks are awakened when the semaphore                                 ___
             is set.  The semaphore will be cleared automatically by the
             multitasking system.

               #define WAITFOR(condition, signo, msecs, result_flag)
               {
                  for (result_flag = SUCCESS);;)
                  {
                      if (condition is true)
                  {
                          result_flag = SUCCESS;
                          break;
                      }
                      if (result_flag == TIMED_OUT)
                          break;
                      result_flag = wait(signo, timeout_value);
                  }
               }
                  #define WAITNOMORE(signo) set_semaphore(signo)

             The first time through the loop, we set the result_flag to
             SUCCESS to bypass the timeout test below.  Also, we must first
             test the condition so we do not cause an unnecessary wait if
             the condition is already true.  If that occurs, we just drop
             out of the loop.  Assuming the condition is not true, the
             timed out test fails, and the wait halts execution.  If
             another task sets the signal by calling WAITNOMORE(),
             execution proceeds, result_flag will be set to SUCCESS, we
             loop again, the condition is retested, and if true, the loop
             breaks.  The other case which can cause the loop to break is
             if the wait times out.  In this case, we begin a new loop.  If
             the condition is now true after the timeout, we set the
             result_flag to SUCCESS anyway and break (it is arguable
             whether an application would need to do it this way, that is
             application specific depending on what information is more
             important, the timeout, or the condition); if the condition is
             still not true, we exit, with result_flag equaling TIMED_OUT.

             Here is a specific example using the MultiTask! pulse event
             where wait is performed via wteset(), and set_semaphore() is                   ____
             performed by pulsevt().






            #define WAITFOR(condition, signo, msecs, flag)
               for (flag=SUCCESS; ; )
               {
                   if (condition)
                   {
                       flag = 0;
                       break;
                   }
                   if (flag != SUCCESS)
                       break;
                   flag = wteset(signo, ((long)msecs*CLOCKHZ)/1000);
               }

          and in WAITNOMORE():

               #define WAITNOMORE(signo) pulsevt(signo)

          The above examples illustrate a problem we will call a blind                                                                 _____
          spot.  One should be aware of this when coding a WAITFOR()          ____
          macro.  The semaphore may be set and cleared (cleared either
          by a receiver or the sender) after the test for condition and                                                          _________
          before the wteset() function.  In other words, the signal is
          set, but this task did not catch it in time before it was
          cleared.  In this case the task will be kept waiting until
          either there is a new signal, or the time limit expires.  This
          is not fatal but may need to be handled differently depending
          on the needs of the application.  How this functions, will
          depend on the capabilities of your multitasking system.

          An ideal WAITFOR() mechanism would be what we might call true                                                                   ____
          events.  Basically, if a count of the number of signals or          ______
          events is available, there is no need to clear the signal.
          These require the following three operations:

            - signal an event
            - get an event count
            - wait until the event count has changed

          With these, the WAITFOR() macro might look like:

               evcnt = getevent(signo);
               while (!condition)
               {
                    flag = waitevent(signo, evcnt, msecs);
                    if (flag)
                        break;
               }

          and there would be no blind spot since the signal never needs
          to be cleared.  If you are writing your own multitasker,
          consider including a capability for returning the number of
          signals which have occurred.






             The WAITFOR() and WAITNOMORE() macros may also be implemented
             using messages received across the network.  A message acts in
             this way very much like a semaphore that wakes up only one
             task, and is automatically cleared by the waiting task.  The
             blind spot here is the case where several tasks are waiting
             for the same signal.  Messages usually require more overhead
             than semaphores.









             7.   DEVICE DRIVERS             7.   DEVICE DRIVERS             ___________________
             --------------------------------------------------------------

             A number of device drivers are already provided with USNET for
             various widely used network controllers.  These include
             Ethernet, Arcnet, and serial connections.  A list of supported
             controllers is provided in the file README.TXT.  If your
             application requires an unsupported controller, you will need
             to write your own device driver.  This chapter describes the
             steps needed for writing device drivers.  If you are using one
             of the supplied drivers, you may still find this chapter
             useful in that it describes the internals of USNET device
             drivers.

             USNET includes two features to assist you with your device
             driver implementation.  Support for interrupt handling is
             provided.  All you need to do is write the interrupt handler
             as a C function and give USNET the name of this function as
             the interrupt handler for the device.  Secondly, USNET
             provides several support functions which will assist with the
             interface between USNET and your driver.  These functions and
             the use of them are presented in this chapter along with a
             description of the interrupt handling mechanism.  Finally, the
             functions required for a device driver are described and
             examples are presented.


             DATA STRUCTURES             DATA STRUCTURES

             Within USNET there are some data structures which can be used
             within a device driver for storing device specific information
             and communication that information to USNET.  You may see how
             they are used in the device driver function examples given
             later in this chapter.  The definitions of these data
             structures may be seen in NET.H.  The data structures are
             described here, however, only the structure fields are
             presented which are relevent to device driver implementation.
             There is much more to these data structures than is presented
             here.  The complete structure may be viewed in NET.H.


             MESSH             MESSH             _____

             Message buffers are required by block drivers to for storing
             incoming and outgoing messages.  A message buffer consists of
             a header and the contents of the message itself.  The message
             header is defined by structure MESSH in NET.H as follows.

               struct MESSH {                  /* internal message header
               */
                   unsigned short mlen;        /* message length */






                unsigned char netno;        /* network number */
                char offset;                /* offset to current level
            */
                ....
            };
            typedef struct MESSH MESS;
            #define MESSH_SZ (sizeof(MESS) | 2)


          The relevant fields are

          mlen           length of the message buffer.  This includes          mlen
                         the message data and the message header.  The
                         message length must be less than or equal too
                         the maximum size of a message buffer (MAXBUF in
                         LOCAL.H).  The size of the message data would
                         be

                         mlen - MESSH_SZ;

          netno          network number.  This is an index into the          netno
                         network table (global variable nets) and
                         indicates the network structure defining the
                         network to be used for this message.

          offset         Generally, this is the message header size          offset
                         (MESSH_SZ).  Adding this value to the address
                         of the message header (or buffer) itself gives
                         the address of the message data.  For instance,

                              unsigned char *byteptr;  /* ptr to message
                         data */
                              MESS *messptr;      /* ptr to message
                         buffer */
                              ....
                              byteptr = messptr + messptr->offset;



          SUPPORT FUNCTIONS          SUPPORT FUNCTIONS

          The following macros and functions are provided to assist you
          with writing your device driver.  They are intended to be used
          as an interface between USNET and a driver.  Use them within
          your driver code to separate device dependent code from USNET
          dependent code.  You will find these macros in file DRIVER.H.
          In most cases you should not need to rewrite these.


          Clear Interrupt          Clear Interrupt          _______________


            CLEARIR(irno)            _____________






             The macro CLEARIR(irno) is defined in DRIVER.H and clears
             interrupt number irno in the interrupt controller.  It does                              ____                               _______
             not clear the device controller.  Note that this is an             _______________________________
             architecture dependent function where different architectures
             will vary greatly on how this is handled.  For the processors
             and controllers supported by USNET, code is supplied to handle
             clearing interrupts for the given architecture.  When writing
             your own driver, you may need to clear the controller's
             interrupt within the device driver code.  This is shown in the
             interrupt handler examples later in this chapter.                                                             _

             Example             _______

               void (*irnew[MAXIRNO])(int arg);
               char irargs[MAXIRNO];
               static void INTERRUPT irhan4() { CLEARIR(4);                                                CLEARIR(4);
               irnew[4](irargs[4]); }

             Taken out of context, this example from file DRIVER.C may
             appear confusing at first.  This simply shows that interrupt
             number 4 is cleared before calling its interrupt handler.
             Irnew[] is an array of pointers to functions (interrupt
             handlers actually).  This code is already within USNET file
             DRIVER.C  (and SUPPA.ASM) and does not need to be written by
             you (unless you are using an unsupported processor).  It is
             simply shown here to illustrate the use of this macro.


             Disable And Enable Interrupts             Disable And Enable Interrupts             _____________________________

             Two macros are defined in DRIVER.H for disabling and enabling
             interrupts.  This is done as follows:

               DISABLE();               DISABLE();
               << code that can not be interrupted >>
               ENABLE();               ENABLE();

             Most of the supplied drivers do not need to use this, however,
             if in the course of writing your own driver you need to insure
             a section of code will not be interrupted, you may use these
             macros to guarantee that.  There is an example of their use in
             NE2100.C


             Install Interrupt Vector             Install Interrupt Vector             ________________________


               void IRinstall(int irno, int netno, void (*irhan)(int
               netno))

             This routine installs a new interrupt handler into the
             interrupt table for interrupt irno.  The interrupt handler is                                           ____
             a function you write within the device driver code. The
             parameters are, interrupt number (irno), network number,                                               ____






          (netno), and a pointer to the interrupt handler function           _____
          (irhan) which takes the network number as a parameter.  When           _____
          an interrupt occurs, the handler will be called with network
          number as an argument.  The network number is an index to the
          USNET data structure which defines the network connection to
          be used by the interrrupt.  This is described further in the
          data structures section in this chapter.  IRinstall()
          automatically saves the old interrupt vector.  The intended
          use of IRinstall() is to call it from the initialization
          routine within your device driver code.  See the section on
          function init() later in this chapter for a specific example
          of its use.


          Restore Interrupt Vector          Restore Interrupt Vector          ________________________


            void IRrestore(int irno)

          This routine restores the original interrupt vector which was
          removed by a previous call to IRinstall().  It is intended to
          be called from the shutdown function within your device
          driver.  See the section on function shut() later in this
          chapter for a specific example.


          Map I/O Address          Map I/O Address          _______________


            char FAR *mapioadd(unsigned long flat)

          This routine converts a flat 32-bit address into a far
          pointer.  It is only needed in segmented architectures that
          expect far pointers.  See file WD8003.C for an example of its
          use.


          Adding Messages to a Queue          Adding Messages to a Queue          __________________________

          The queue macros are used with block drivers to manipulate
          arriving and departing messages and the USNET queues which
          control them.  Note that these macros are only relevant to
          block drivers.

          When an interrupt occurs indicating the network controller has
          received a new message, your interrupt handler will need to
          add this new message to the appropriate USNET queue.  To queue
          an arrived message, use the macro

            QUEUE_IN(ptr, qname, mess)

          where mess is a pointer to the message, and ptr is a pointer                ____                                  ___
          to the network structure nets[netno].  The network structure                                   ____________
          contains fields which are pointers to message queues (see






             struct NET in NET.H).  The qname parameter allows you to                                        ______
             specify which queue to add the message to.  It takes a value
             of either arrive or depart.  These are keywords which you do                       ______    _______
             not need to predefine.  The macro uses these in its string
             replacement as names of fields within the struct NET.

             Examples             ________

               static void irhan(int netno)
               {
                  MESS *mess;
                  struct NET *netp;
                  ....

                  netp = nets[netno];                  /* nets is a global
                  USNET table */
                  mess = << get message from controller's memory >>
                  ....
                  QUEUE_IN(netp, arrive, mess);                  QUEUE_IN(netp, arrive, mess);
                    ....
               }  /* end irhan */

             This example shows how QUEUE_IN() would be used in the
             interrupt handler (discussed later in this chapter) to add an
             arrived message to the arrived message queue.  The four                                    ________________________
             periods and the << >> symbols in this, and subsequent examples
             represent additional code which does not directly relate to
             this example and has been removed.

             To queue a message for transmission use the departure queue.
             One place where this may be used is within the writE()
             function (also discussed later) which may be used to send a
             message to the network.

               static int writE(int conno, PTABLE **protoc, MESS *mess)
               {
                  struct NET *netp;                       /* ptr to network
                  structure for this device.*/
                  ....
                  netp = &nets[mess->netno];      /* get ptr to network
                  required for this message */
                  ....
                  QUEUE_IN(netp, depart, mess)    /* add to departure queue                  QUEUE_IN(netp, depart, mess)
                  */
                  ....
               } /* end writE */


             Queue Full             Queue Full             __________

             The QUEUE_FULL() macro may be used to test for a full queue
             before attempting a QUEUE_IN().  The syntax is

               QUEUE_FULL(ptr, qname)







          Ptr is a pointer to the network structure nets[netno] and          ____                                      ___________
          qname is the queue to be tested.          ______

          Example          _______

            static int writE(int conno, PTABLE **protoc, MESS *mess)
            {
            struct NET *netp;
            .....
            netp = &nets[mess->netno];      /* get ptr to network
            required for this message */
            if (QUEUE_FULL(netp, depart))                QUEUE_FULL(netp, depart)
               Nprintf("Error: departure queue full.\n");
            else
               QUEUE_IN(netp, depart, mess);


          Removing Messages from a Queue          Removing Messages from a Queue          ______________________________

          The macro QUEUE_OUT() may be used to remove a message from a
          given queue and place it in a message structure.  Its syntax
          is similar to QUEUE_IN().

            QUEUE_OUT(ptr, qname, mess)

          The parameters are identical to those for QUEUE_IN().

          Example          _______

            irhan(int netno)
            {
               MESS *mess;
               struct NET *netp;
               ....
               netp = &nets[netno];
               ....
               QUEUE_OUT(netp, depart, mess);               QUEUE_OUT(netp, depart, mess)
               <<write message to network controller >>
               ....
            }

          This removes a message from the departure queue before writing
          it to the controller (the device).  Refer to NE2000.C for a
          specific example.


          Queue Empty          Queue Empty          ___________

          The QUEUE_EMPTY() macro may be used to test for an empty queue
          before attempting a QUEUE_OUT().  The syntax for QUEUE_EMPTY()                                                          _
          is

            QUEUE_EMPTY(ptr, qname)







             Ptr is a pointer to the network structure nets[netno] and             ____                                      ___________
             qname is the queue to be tested.             ______

             Example             _______

               irhan(int netno)
               {
                  MESS *mess;
                  struct NET *netp;
                  .....
                  netp = &nets[netno];
                  ....
                  if (QUEUE_EMPTY(netp, depart))                      QUEUE_EMPTY(netp, depart)
                       << process error >>
                  else
                  {
                       QUEUE_OUT(netp, depart, mess);
                       <<write message to network controller >>
                  }
                  .....
               }

             Refer to NE2000.C for a specific example.


             Writing/Reading to/from the Controller             Writing/Reading to/from the Controller             ______________________________________

             The PC version of USNET provides macros _inb(), _outb(),                                                     ________________
             _inw(), and _outw() for reading and writing bytes and words             _______     _______
             with a given address.  These are used to send and receive data
             directly to and from the network controller device via a
             hardware address.  These macros are processor and compiler
             dependent and may not be provided for your architecture.  The
             point here is this will be an operation within your driver you
             will need to do.  You may see examples of their use in the                             __
             device driver sourcecode for the PC, for instance, files
             WD8003.C, NE2000.C, and I8250.C with USNET installed for the
             8086..


             INTERRUPT HANDLING             INTERRUPT HANDLING

             If you are using a USNET supported processor, interrupt
             support has been placed in module DRIVER.C, which uses the
             header file DRIVER.H.  The interrupt handlers in the drivers
             are subroutines called from stub routines in C (DRIVER.C) or
             assembler (SUPPA.ASM) depending on the compiler support.  The
             purpose for this design is to separate the processor dependent
             interrupt handling from the network controller device driver
             code.  In other words, the interrupt handler within the device
             driver will be called from one of these interrupt stubs.

             The stub performs the following tasks:







            1. It saves all registers.

            2. It clears the interrupt for the processor, if needed by
               using macro CLEARIR(). (Clearing it for the device is up
               to the driver.)

            3. It initializes what might be needed to call C code.  As
               an example, in 8086 it must clear the direction flag.

            4. It calls the driver handler with one argument: the
               network number.  For the I8086 and I386 versions, this is
               picked up from a table indexed by the interrupt number.
               For the other processors, each network has its own stub
               handler, so the index is simply picked up as a constant.

          Now, the network controller interrupt handler code can be
          written as an ordinary processor-independent C function.

          This simple scheme may leave the interrupts disabled for the
          entire driver call.  In most cases this is just fine in
          networking.  Nested interrupts are properly supported by
          hardware.  Any attempts to augment them with clever schemes
          are, in the high-pressure world of networking, unwise and
          unsafe.  USNET will not be hurt by a few lost interrupts.

          Clearing the interrupt controller (which is not needed in many
          processors) should normally be done first, not last.  As was
          already mentioned, this is done in the interrupt stub.  If you
          do it after you have cleared the device interrupt, you may
          clear the next interrupt also.  There are cases though where
          interrupt clearing gets so complicated that it has to be
          written into the driver.


          CONFIGURING INTERRUPT TABLE SIZE          CONFIGURING INTERRUPT TABLE SIZE

          For the I8086 and I386 only you may specify the size of the
          DRIVER.C interrupt tables with the parameter MAXIRNO in
          DRIVER.C.


          CONFIGURING FOR AN UNSUPPORTED PROCESSOR          CONFIGURING FOR AN UNSUPPORTED PROCESSOR

          If USNET already provides support for your processor you may
          ignore this section.  Otherwise, you will need to make the
          following alterations for the unsupported processor.


          1.   DRIVER.H macro DISABLE() disables interrupts, ENABLE()                                                            _
             enables them.  Alter these macros so they operate for your
             processor.
               






             2.   For writing the interrupt support, if your compiler
                supports C level interrupt functions, you may use the m68k
                DRIVER.C code as a base to start with.  For assembly stubs,
                borrow the hc16 code, and the interrupt stub irstub() in                                                                      
                SUPPA.ASM.
                  
             3.   If you need to clear the interrupt, do this at the start
                of each interrupt stub.  If these are in C, you may do this
                by defining macro CLEARIR(irno) in DRIVER.H.  See DRIVER.H
                for the I8086 for an example.
                  
             4.   Complete DRIVER.C routines IRinstall() and IRrestore().
                These may need code to unmask and mask interrupts, as in
                the x86 versions.  You need to install and to retrieve
                interrupt handlers.  This may use ready-made routines (as
                for the x86), or assembly code (hc16), or mostly C (m68k).
                  
             5.   Routine mapioadd() returns a memory-mapped I/O address as
                a far pointer.  If there are no far addresses, it should
                just return the argument typecast as a pointer.


             ERROR CODES             ERROR CODES

             Two error codes you may want to use as return codes from your
             driver functions are NE_HWERR, and NE_PARAM.  These are
             defined in NET.H (you will need to #include NET.H to use
             them).  NE_HWERR is used to returned hardware errors occurring
             in the device driver.  NE_PARAM is used to indicate bad
             parameters were passed to the device in the initialization
             routine.  Some of the example driver routines later in this
             chapter use these return code.  The driver will send the
             return codes to USNET, which will in turn pass the error to
             your application via the user interface functions.


             WRITING A DEVICE DRIVER             WRITING A DEVICE DRIVER

             When you write a device driver, you need to include the
             following functions:  irhan(), init(), shut(), opeN(),                                   ________________________________
             closE(), reaD(), writeE(), and screen().  Depending on your             __________________________     _________
             implementation, some of these may be not be needed.  Also, you
             need to assign these functions to a PTABLE.  This is a table                                                 ______
             of pointers to your driver functions and is the mechanism
             USNET uses to call them.

             For example, the format for the driver is as follows:






            irhan(int netno)
            {
               ....
            }

            init()
            {
               ....
            }

            shut()
            {
               ...
            }

            etc

            PTABLE ptable("driver name", irhan, init, shut, etc, );

          which function gets called at what time depends on the field
          it is assigned to within the table, i.e., when USNET expects
          the shut() function it will call the third function
          Therefore, position with the table is crucial.  Each function
          and the PTABLE is described in more detail in the sections on
          character and block drivers.


          CHARACTER DRIVERS          CHARACTER DRIVERS

          The function of a character driver is to get and to send                            ________________
          characters between a network controller and the link layer.
          It does not know what the characters mean, where they go, or
          where they come from.  The driver does not assemble characters
          into messages, because this is a protocol-dependent job.
          Likewise, it does not disassemble a message into characters.
          A character driver would be typical of a serial driver.

          The following picture shows how incoming data is handled
          within USNET as the data is transferred between the network
          controller and the application.  The logic flows from top to
          bottom.  The part above the wider line is performed on one
          character at a time.







                                           +-------------+
                                   device   data                                           |             |
                                            available                                           |             |
                                            interrupt                                           |             |
                                           |-------------|
                                   driver   get                                           |             |
                                            character                                           |             |
                                            call                                           |             |
                                            comingc()                                            comingc()                                           |             |
                                           |-------------|
                                   link     add to                                           |             |
                                     layer  message                                           |             |
                                            queue when                                           |             |
                                            done                                           |             |
                                           |-------------|                                            -------------
                                   TCP/IP   screen()                                            screen()                                           |             |
                                            checks,                                           |             |
                                            processes                                           |             |
                                           |-------------|
                                   user     Nread() gets                                            Nread()                                           |             |
                                   applica  message                                           |             |
                                     tion                                           |             |                                           |             |
                                           +-------------+


             Outgoing data is handled according to the following diagram,
             again from top to bottom.  The boxes below the wider line are
             done for each character.








                                        +--------------+
                                 user     Nwrite()                                          Nwrite()                                        |              |
                                 applic     message                                        |              |
                                   atio                                        |              |
                                   n                                        |              |
                                        |--------------|
                                 TCP/IP   writE() adds                                          writE()                                        |              |
                                          headers                                        |              |
                                        |--------------|                                         --------------
                                 link     add to send                                        |              |
                                 layer    queue                                        |              |
                                        |--------------|
                                 device   transmit                                        |              |
                                            empty                                        |              |
                                          interrupt                                        |              |
                                        |--------------|
                                 driver   call                                        |              |
                                            goingc(),                                            goingc(),                                        |              |
                                          send                                        |              |
                                            character                                        |              |
                                          to device                                        |              |                                        +--------------+


          The code you must write for your own device driver is
          represented at the driver level in the diagrams above.
          Therefore, for reading data, you must retrieve the character
          from the controller (device) and pass it to the link layer via
          the routine comec().  Similarly, for sending goingc() is used.
          Comec() and goingc() are within the link layer sourcecode.
          Their purpose is to act as an interface between the driver and
          link layer which enables the device driver to be written as a
          separate module from the link layer.  This greatly simplifies
          the writing of device drivers.  Refer to module SLIP.C for an
          example of how comec() and goingc() are implemented.

          Interrupting on each character is time-consuming.  As a rule
          of thumb, an Intel 386 can handle at most 38,400 bits per
          second this way - less if a DOS extender is used.  Higher
          rates than this require either a FIFO buffer in the serial
          port, or the use of DMA.

          USNET character drivers are short and simple, and will work in
          any protocol stack.  A typical size would be 200 lines of
          code.  The easiest way to produce a new driver is probably by
          editing the I8250 code.

          The following explains the routines and data structures of a
          character driver.  The examples provided are based on the code
          for the I8250.C driver.  In some places, some of the original
          code not relevant to the discussion has been removed and
          replaced with four period symbols or with angle brackets and






             some psuedocode (such as << write message to buffer >>).
             Refer to the sourcecode in I8250.C to see a specific
             implementation of these routines.  Comments which are not part
             of the original code have been added to the examples for
             explanation.  Recognize that some of the code in these
             examples is device dependent and will be different for your
             device, particularly the _outb() and _inb() calls.  Study the
             examples for understanding the process, but don't get bogged
             down in the device dependent details.


             Interrupt Handler             Interrupt Handler             _________________


               static void irhan(int netno)

             This is a regular C function, called from the interrupt stub
             which is triggered when a network I/O interrupt occurs.  The
             argument is used to index to the network tables.

             The code for irhan() should determine the status of the
             interrupt.  If this is transmitter empty the handler needs to                                    _________________
             send a character to the device and must call the routine
             goingc() (via the network structure) to get a character to
             transmit.  If goingc() returns the value -1, there is no data
             ready for transmission.

             If the interrupt is data available, then the device has data                                 _______________
             to be received, the driver should take a character from the
             device and give it to routine comec() (again through the
             network structure).

             The handler must make sure that the interrupt is cleared
             before it returns.  In some cases (the I8250 among them), the
             handler must check for further interrupts before returning.






          Example          _______

            /*==========================================
               C level interrupt handler.  Called from a stub.  Returns
            to the interrupt stub.
            */
            .
            static void irhan(int netno)
            {
               int char;                            /* character to be
               sent or received. */
               unsigned int tport;              /* device I/O port */
               unsigned char status;          /* interrupt status */
               struct NET *netp;               /* pointer to network
               structure */

               netp = &nets[netno];  /* assign a ptr to current network
               struct via index netno */
               tport = netp->port;    /* get address of the device I/O
               port */

               while ((status = _inb(tport+IIR) & 7) != 1)     /* which
               interrupt occurred? */
               {
                  ....
                  switch (status)                             /* switch
                    on which interrupt occurred */
                  {
                    ....
                    case 2:                                        /*
                    Transmitter empty interrupt    */
                      char = netp->hw.goingc(netp); /* get the char to
                    be transmitted */
                      if (char != -1)
                         _outb(tport+THR, char);      /* write char to
                    device */
                      else                                        /* no
                    char available at present    */
                         _outb(tport+IER, _inb(tport+IER) & 0xd);
                         break;
                    case 4:                                          /*
                    data available from device. */
                         netp->hw.comec(_inb(tport+RDR), netp); /* inb
                    reads from device*/
                         break;
                    /* comec sends to link layer */
                        ....
                  }  /* end case */
               }  /* end while */
               ....
            } /* end irhan */

          All references to device refer to the network controller.                            ______
          Comec() is accessed via a pointer to the function stored in a






             field of the network structure.  This is preassigned by USNET
             during initialization; all you need to do is just call it.


             Transmit Routine             Transmit Routine             ________________


               static int writE(int conno, char *protoc, MESS *mess)

             WriteE() is used to make a character available to the
             interrupt handler.  It is called whenever your application
             calls the Nwrite() function explained in the chapter on the
             USNET user interface.  The arguments are: connection number,
             conno, protocol path, protoc, and a message pointer, mess.             _____                 ______                         ____
             This routine enters the message in the departure queue.  This
             makes it available to the interrupt handler which sends it
             when a transmitter empty interrupt occurs.  If the device is
             not busy, it generates the transmitter empty interrupt.  It
             then returns and allows  the interrupts to take care of the
             rest.






          Example          _______

            /*==========================================
               Transmit routine.  Enters the message in the departure
            queue.  If link is
               busy just returns.  Otherwise generates the interrupt and
            returns.
               Returns:
                    error:  -1
                    queued or started:  0
            */

            static int writE(int conno, PTABLE **protoc, MESS *mess)
            {
                int tport;                                  /* device
            I/O port */
                struct NET *netp;                      /* ptr to network
            structure for this message */

                (void)conno, (void)protoc;           /* first two
            parameters are not needed here */
                netp = &nets[mess->netno];      /* get ptr to network
            required for this message */
                tport = netp->port;                   /* assign I/O port
            */
                mess->offset = mess->netno;
                BLOCKPREE();                           /* block task
            switching */
                if (QUEUE_FULL(netp, depart))     /* if queue is full,
            process error */
                     << process queue full error >>
                QUEUE_IN(netp, depart, mess);              /* add
            message to departure queue */
                _outb(tport+IER, _inb(tport+IER) | 2);    /* generate
            the transmit interrupt    */
                RESUMEPREE();                                    /*
            resume task switching */
                return 0;
                ....;
            }

          You can see here that the writE() uses the macros QUEUE_FULL()
          and
          QUEUE_IN() discussed earlier in this chapter to perform the
          queue operations.
          In this case, the parameters for connection number and
          protocol path are not used.  Nevertheless, they are required
          for compatability with the USNET protocol path data structures
          which store and call this routine.


          Open Connection          Open Connection          _______________






               static int opeN(int conno, char *protoc, int flag)

             Normally no action is needed.  If, however, your network
             controller has some special needs when opening a connection,
             you may use opeN() to run it.  This routine would be run when
             your application makes a call to Nopen().  The parameters are
             the connection number, conno, for the open connection, the                                    _____
             protocol path, protoc, and a flag.  The flag may be used for                            ______
             opening connections with different options relevant to some
             devices.  For example the WD8003 (not a character driver)
             allows a monitoring option for receiving or rejecting
             different types of network messages.


             Close Connection             Close Connection             ________________


               static void closE(int conno, char *protoc)

             Normally no action needed.  If, however, your network
             controller has some special needs when closing a connection
             you may use closE() to run it.  This routine would be called
             when your application makes a call to Nclose().  The
             parameters are similar to those for opeN().


             Configure and Start Up             Configure and Start Up             ______________________


               static int init(int netno, char *protoc, char *params)

             This routine processes the hardware parameters, calls the
             optional adapter initialization, sets up the controller, and
             stores data into the network table.  The arguments are network
             number, netno, protocol path, protoc, and the device                     _____                 ______
             initialization parameters, params.  The initialization                                        ______
             parameters are the same string you configured in the network
             configuration table (see the chapters on network
             configuration). Then it calls routine IRinstall() to store the
             interrupt address and enable the interrupt.  This routine is
             called from USNET when your application uses function
             Portinit().

             The initialization parameters for the I8250 are the baud rate,
             the I/O port address and the interrupt number.  Another device
             might need different parameters, for instance two separate
             interrupt numbers.






          Example          _______

            /*======================================
               Configure and start up the 8250 interface.  We process
            the user-level
               text parameters and store the values into the net table.
            We initialize
               the controller.  Then we store the interrupt address and
            enable the
               interrupt.
            */

            static int init(int netno, PTABLE **protoc, char *params)
            {
                int i1, tport;
                long l1;
                char *cp1, par[16], val[16];
                struct NET *netp;

                netp = &nets[netno];
            /* assign ptr to network struct */
                for (cp1=params; *cp1; )
            /* for each parameter.... */
                {
                    Nsscanf(cp1, "%[^=]=%s %n", par, val, &I1);      /*
            parse the parameter */
                    cp1 += i1;
                    if (strcmp(par, "IRNO") == 0)                   /*
            determine which param it is    */
                        Nsscanf(val, "%d", &netp->irno[0]);       /*
            assign it to the appropriate */
                    else if (strcmp(par, "PORT") == 0)             /*
            field within the net struct   */
                        Nsscanf(val, "%i", &netp->port);
                    else if (strcmp(par, "CLOCK") == 0)
                        Nsscanf(val, "%ld", &l1);
                    else if (strcmp(par, "BAUD") == 0)
                        Nsscanf(val, "%ld", &netp->bps);
                    else
                        return NE_PARAM;
                }
                i1 = protoc[1]->init(netno, protoc+1, params);   /* call
            adapter init function */
                if (i1 < 0)
            /*    from the protocol path */
                    return i1;

            /* initialize baud rate and other device specific
            initializations */
                tport = netp->port;
                _outb(tport+LCR, 0x80);                     /* set baud
            reg access */
                i1 = l1 / netp->bps;                        /* set baud
            rate */






                   _outb(tport+BRDH, i1>>8);
                   _outb(tport+BRDL, i1);
                   _outb(tport+LCR, 0x03);                     /* set LCR
               value */
                   _outb(tport+IER, 0x03);                     /* set IER
               value */
                   _outb(tport+MCR, 0x0b);                     /* set MCR
               value */
                   i1 = (int)(char)_inb(tport+LSR);    /* clear any line
               status interrupt */
                   if (i1 == -1)
                       return NE_HWERR;
                   (void)_inb(tport+RDR);              /* clear any receive
               interrupt */
                   (void)_inb(tport+IIR);              /* clear any
               transmitter interrupt */
                   (void)_inb(tport+MSR);              /* clear any modem
               status interrupt */

                   IRinstall(netp->irno[0], netno, irhan);     /* install
               device driver interrupt handler */
               }

             The device intialization section uses a number of _outb() and
             _inb() calls along with the device I/O port address tport.                                                                 _____
             See I8250.C for specifics.  This type of code is what will be
             different for your device's architecture.


             Shut Down             Shut Down             _________


               static void shut(int netno, char *protoc)

             Shut() turns off the controller and calls the optional adapter
             shutdown.  It also calls routine IRrestore() to restore
             original interrupt status that existed before USNET was
             initialized.  The arguments are network number and protocol
             path.  Shut() is called by USNET whenever Portterm() is called
             from the application.






          Example          _______

            /*======================================
               Shut down the 8250 interface.  Turns off the controller.
            Restores original
               IRQ, mask and vector.
            */

            static void shut(int netno, PTABLE **protoc)
            {
                int tport;                                           /*
                struct NET *netp;

                (void)protoc;                                     /*
            protocol path not used */
                netp = &nets[netno];                         /* assign
            ptr to network to be shutdown */
                tport = netp->port;                           /* get
            port I/O address */
                while (!(_inb(tport+LSR) & 0x40));       /* these 3
            lines are device specific */
                _outb(tport+IER, 0);                           /*
            shutdown stuff */
                _outb(tport+MCR, 0);
                IRrestore(netp->irno[0]);                     /* restore
            the original interrupt */
            }

          The _out() and _inb() calls are device specific shutdown
          commands.  If you are writing your own device driver, these
          calls would be specific to the architecture of your network
          controller.


          Protocol Table          Protocol Table          ______________

          A protocol table is used by USNET to call functions specific
          to a given protocol or device.  A PTABLE is defined as follows






               struct Ptable {                                       /*
               protocol table, at end of each module */
                   char name[10];                                  /* name
               of protocol */
                   int (*init)(int, PTABLE **, char *);        /*
               initialize */
                   void (*shut)(int, PTABLE **);               /* shut */
                   int (*screen)(MESS *);                        /* screen
               */
                   int (*opeN)(int, PTABLE **, int);          /* open */
                   void (*closE)(int, PTABLE **);             /* close */
                   MESS *(*reaD)(int, PTABLE **);          /* receive */
                   int (*writE)(int, PTABLE **, MESS *);   /* send */
                   int Eprotoc;                                        /*
               external protocol number */
                   unsigned char hdrsiz;                           /*
               header size */
               };

             Here, you can see a PTABLE is basically, a structure of
             pointers to functions.  USNET uses this structure to call the
             protocol, link layer and device specific functions when they
             are needed.  In other words, USNET will call your device
             driver functions by using pointers to them stored within a
             PTABLE entry.  Be sure you add to your function names to the
             proper fields (see the example below).  When USNET expects to
             call the device driver init() function for instance, it better
             be the init() function which is assigned to the init field
             within the PTABLE, otherwise your driver certainly will not
             operate properly.

             Example             _______

               PTABLE I8250_T = {"I8250", init, shut, 0, opeN, closE, 0,
               writE, 0, MESSH_SZ};

             The value "I8250" is the name of the driver, all others are
             normally fixed as you see here.  The zeros are used for
             functions which are not needed.  In this case, reaD(), and
             screen() are not needed (or implemented for that matter) by
             the device driver.  Screen() is generally used by protocol
             layers higher than the device driver level, and reaD() is
             generally not needed since the interrupt handles the reading
             of data from the device and sending it to the link layer.


             BLOCK DRIVERS             BLOCK DRIVERS

             A block driver receives and sends whole messages rather than               ____________
             characters between the network controller and the link layer.
             It neither examines nor supplies any message contents.  An
             example of a block driver would be one which communicates with
             an Ethernet controller.  Because whole messages are handled at






          a time, block drivers are implemented differently from
          character drivers.

          The following picture shows how incoming data is handled
          within USNET as the data is transferred between the network
          controller and the application.  The logic flows from top to
          bottom.


                                   device     data available
                                                    interrupt

                                    driver     get message
                                                 queue it

                                link layer     screen() checks,                                               screen()
                                  TCP/IP      processes

                                user            Nread() gets                                                Nread()
                             application      message


          Outgoing data is handled similarly, again, the sequence is
          from top to bottom.


                              user            Nwrite() message                                              Nwrite()
                           application

                              TCP/IP           writE() adds                                               writE()
                               link layer         headers

                               driver          copy to buffer
                                                       writE()                                                       writE()

                               device            controller
                                                 sends message


          USNET block drivers are short and simple, and will operate in
          any protocol stack.  A typical size would be 300 lines of
          code.  The easiest way to produce a new driver is probably by
          editing the WD8003 code.

          The following explains the routines and data structures of a
          block driver.  A block driver may be written either with or
          without a transmit interrupt.  The transmit interrupt simply                    __________________
          allows the sending of a message by the controller to be
          interrupt controlled.  If a transmit interrupt is not
          available, then the writE() routine is used for triggering the
          device to send the message.  If one is used, then sending is
          handled by the interrupt handler and it becomes an interrupt
          driven task.






             The following sections present each block driver function and
             show examples of their implementation.  Use this as a guide
             for building your own block device driver.  The code would be
             written differently if a transmitter interrupt was present
             than if it was not.  Examples of both are given.  The
             transmitter interrupt examples are based on the NE2000.C code
             and the non-transmitter interrupt examples are based on the
             WD8003.C code.  Refer to these files for specific
             implementations.  In some cases, code from the original driver
             has been replaced by either four periods or << psuedocode >>
             symbols where it was not relevant for understanding the
             example.  As for character drivers, comments which are not
             part of the original code have been added to the examples for
             explanation.  Recognize that some of the code in these
             examples is device dependent and will be different for your
             device, particularly the _outb() and _inb() calls.  Study the
             examples for understanding the process, but don't get bogged
             down in the device dependent details.



             Interrupt Handler             Interrupt Handler             _________________


               static void irhan(int netno)

             This is a regular C function, called from the interrupt stub
             which is triggered when a network controller interrupt occurs.
             The argument is used to index to the network tables and locate
             the network structure for this device.

             This first example shows an interrupt handler that does not
             use the transmit interrupt.






          Example          _______

            /*==========================================
             C level interrupt handler for Ethernet.  Called from a
             stub, registers are saved.  Queues the arrived message into
             the arrive queue of the network block.  We pad the Ethernet
             header with an extra 2 bytes for 32-bit machines.  Returns
             to the interrupt stub.
            */

            static void irhan(int netno)
            {
               int i2;
               unsigned int len, tport;                 /* device I/O
               port */
               unsigned char rcv,                       /* interrupt
               status */
                                   start,
                                   next;
               char FAR *shp,                           /* shared memory
               pointer */
                             *bp;                            /*  buffer
               pointer */
               MESS *mess;                             /* incoming or
               outgoing message */
               struct NET *netp;                        /* the network
               definition for this controller */

               netp = &nets[netno];                   /* assign network
               ptr   */
               tport = netp->port;                     /* get port I/O
               address */

               /* find out which interrupt occurred.  If no message
               available, record the
                   error and return.  Record errors in the network
               structure.
               */
               if ((rcv = _inb(tport+ISR)) & (MSK_PRX|MSK_RXE))
               {
                if ((rcv & SMK_PRX) == 0)
                {
                  if (rcv & SMK_CRC) netp->err[3]++;          /* record
                    errors and return */
                  if (rcv & SMK_FAE) netp->err[4]++;
                  if (rcv & SMK_FO) netp->err[5]++;
                  if (rcv & SMK_MPA) netp->err[6]++;
                      goto ret;
                }

               /* Now, there is a message, so check that it's reasonable
                and assign variables and pointers to portions of the
                message so it may be copied to USNET's MESSH structure
                later.  THIS IS VERY DEVICE DEPENDENT.






                  */
             amess:     start = _inb(tport+BNRY) + 1;
                   if (start >= OUTPAGE)
                   {
                       netp->err[0]++;
                       goto ret;
                   }
                   shp = netp->base[0] + (SHAPAGE * start);
                   shp++;
                   next = *shp++;
                   if (next >= OUTPAGE)
                   {
                       netp->err[0]++;
                       goto ret;
                   }
                   len = *((short FAR *)shp);
                   shp += 2;
                   len -= 4;
                   if (len > MAXBUF - MESSH_SZ)
                   {
                       netp->err[1]++;
                       goto ret3;
                   }

                   /* message now looks good, be sure the arrive queue is
                  not full */
                   if (QUEUE_FULL(netp, arrive))
                       goto ret3;

                   /* Copy the message into a buffer, queue for
                  dispatching. */
                   if ((mess = NgetbufIR()) == 0)           /* get a new
                  message buffer */
                       goto ret3;
                   mess->netno = netno;                       /* assign
                  values to fields of message */
                   mess->mlen = len + MESSH_SZ;        /*    struct, see
                  MESSH in NET.H    */
                   mess->offset = MESSH_SZ;
                   bp = (char *)mess + mess->offset;
                   if (next && next < start)
                   {                                            /* now,
                  copy the message into the buffer */
                     i2 = (OUTPAGE - start) * SHAPAGE - 4;
                     Nfarcpy(bp, shp, I2);                             /*
                  copy from shared memory to buffer*/
                     len -= i2;
                     if ((int)len <= 0) goto ret3;
                     bp += i2;
                     shp = netp->base[0];
                   }
                   Nfarcpy(bp, shp, len);                          /* copy
                  from shared memory to buffer*/






                QUEUE_IN(netp, arrive, mess);              /* add
               message to arrive queue */
                WAITNOMORE_IR(SIG_RN(netno));        /* trigger network
               task if          */

          /* multitasking is enabled.        */
          ret3:        ....
                goto amess;
               }

               /* At end clear the interrupt, go back to stub. */
          ret:      _outb(tport+ISR, -1);

            }  /* end irhan */


          The code for irhan() first checks which interrupt took place.
          If this is not "data in" it does nothing.  Otherwise, and if
          there is a message, the handler takes it, and checks it for a
          reasonable format (but not for protocol).  The handler                                 ____
          allocates a buffer with the function getbufIR(), queues the
          message with the QUEUE_IN() macro, and kicks off the network
          task with the operation WAITNOMORE_IR().  A number of values
          must be assigned to fields in the USNET MESSH structure which
          defines a message to USNET.  The interrupt handler must make
          sure that the interrupt is cleared before it returns.  In some
          cases (the WD8003 among them), the handler must check for
          further interrupts before returning.  Nfarcpy() is used to
          copy.between memory locations.  It provides an architecture
          independent routine which can be used to hide the details of
          copying in, for example, segmented architectures.

          If a transmit interrupt is available, the interrupt handler
          may also contain code for sending the message to the device.
          A transmit interrupt is handled in the following way.

          - If the departure queue is empty, mark the transmitter free.

          - If the queue is not empty, take the first element using the
            macro QUEUE_OUT,  and initiate a new transmission.

          Example          _______

            static void irhan(int netno)
            {
                int status;                                         /*
            interrupt status */
                unsigned int tport, len;               /* device I/O
            port, message lenght */
                MESS *mess;                  /* message buffer */
                struct NET *netp;            /* network structure */

            /* get and clear interrupt status */






                   netp = &nets[netno];              /* assign network
               structure */
                   tport = netp->port;               /* assign I/O port */
                   _outb(tport+CMDR, MSK_PG0);
                   status = _inb(tport+ISR);         /* get interrupt
               status */
                   _outb(tport+ISR, status);

               /* receive interrupt */

                   if (status & (MSK_PRX+MSK_RXE))
                   {
                       << process receive interrupt--removed from example
               to save space >>
                   }
               /* transmit interrupt, send out the next message from the
               departure queue */
                   if (status & (MSK_PTX+MSK_TXE))               /* if a
               transmit interrupt occurs */
                   {
               lab6:   if (QUEUE_EMPTY(netp, depart))              /* is
               the queue empty? */
                           netp->hwflags = 0;
               /*      yes, mark transmitter free */
                       else
               /* if not, continue */
                       {
                           QUEUE_OUT(netp, depart, mess);           /* get
               message from departure queue */
                           if (mess->offset != netno)
                               goto lab6;
                           netp->bufbas = mess;
                           len = mess->mlen - MESSH_SZ;
                           spt = (short *)((char *)mess + MESSH_SZ);
                           if (len < ET_MINLEN) len = ET_MINLEN;
                           _outb(tport+TBCR0, (len&0xff));             /*
               write message to device */
                           _outb(tport+TBCR1, (len>>8));

                           << much device dependent code here>>

                           mess->offset = MESSH_SZ + LHDRSZ;
                           if (mess->id <= bWACK)               /* test to
               see if we can release the buffer */
                           {
               /* this may depend on an ACK */
                               if (mess->id == bRELEASE)
                               {
                                   mess->id = bALLOC;
                                   NrelbufIR(mess);
                               }
                           }
                           else






                            WAITNOMORE_IR(SIG_WN(netno));    /* wake up
            waiting tasks */
                    }
                }



          Transmit Routine          Transmit Routine          ________________


            static int writE(int conno, char *protoc, MESS *mess)

          This is called from USNET when your application performs an
          Nwrite().  The arguments are: connection number, protocol
          path, message address.  (But if the protocol argument is zero,
          the first argument is the network number.)

          There are two basic sending strategies: with or without a
          transmit interrupt.  Not using one involves the following:

            -  copy the data to the controller
            -  initialize and start the transmission
            -  wait until it is done
            -  check status, return a negative value for error, positive
          for success






             Example             _______

               /*==========================================
                 Transmit routine.  Copies message to the output area of
                 the shared memory, tells the controller to send it, waits
                 until all is clear.
                 Returns:
                   error:    -1
                   success:  length of message
               */

               static int writE(int conno, PTABLE **protoc, MESS *mess)
               {
                   int tport, i1, stat, len;         /* device I/O port,
               return status, message length */
                   char FAR *shp;                         /* shared memory
               address */
                   struct NET *netp;                 /* network structure
               */

                   i1 = protoc ? connblo[conno].netno : conno;      /* get
               current connection num */
                   netp = &nets[i1];
               /* assign ptr to network def'n */
                   tport = netp->port;
               /* get port I/O address */

                   len = mess->mlen - MESSH_SZ;
               /* mess len minus mess hdr */
                   shp = netp->base[0] + (SHAPAGE * OUTPAGE);   /* set
               shared mem ptr to correct*/

               /*    address. */
                   BLOCKPREE();
               /* block task switching */
                   Nfarcpy(shp, (char *)mess+MESSH_SZ, len);   /* copy mess
               to from buff to */
                                                /*      shared memory */
               /* device dependent code to transmit message */
                   if(len < ET_MINLEN) len = ET_MINLEN;
                   _outb(tport+TBCR0, len);
                   _outb(tport+TBCR1, (len >> 8) );
                   _outb(tport+TPSR, OUTPAGE);
                   _outb(tport+CMDR, MSK_TXP + MSK_RD2);
                   while (_inb(tport+CMDR) & MSK_TXP);
                   stat = _inb(tport+TSR);
                   RESUMEPREE();
               /* resume task switching */
               ....
                   if (stat & SMK_FU)                      /* if transmit
               errors exist, set errors in */
                       netp->err[8]++;                    /*     network
               structure. */
                   if (stat & SMK_COL)






                    netp->err[9]++;
                if (stat & SMK_ABT)
                    netp->err[10]++;
                return NE_HWERR;                     /* return hardware
            error to USNET.*/
            }

          Not using a transmit interrupt is simpler (saves some code in
          the interrupt handler), but may be less efficient.  Sending
          with the transmit interrupt means the interrupt handler does          ____
          the actual transmit.  In this case the writE() is performed as
          follows:

            -  check flag for transmitter idle
            -  if yes, copy the data, start the transmission
            -  if no, queue the message with the macro QUEUE_IN().
            -  return zero
            -  the interrupt handler will mark the transmission
               complete, and start the next message from the queue

          Example          _______

            /*==========================================
               Transmit routine.  If the transmitter is idle, starts the
            transmission and
               returns.  Otherwise adds message to the departure queue;
            the interrupt
               handler will trasmit it.  Returns:
                    error:    -1
                    success:  0
            */

            static int writE(int conno, PTABLE **protoc, MESS *mess)
            {
                int tport, i1, len, netno, stat;
                short *spt;
                struct NET *netp;

                netno = protoc ? connblo[conno].netno : conno;
                netp = &nets[netno];
            /* get network structure */
                tport = netp->port;
            /* get device I/O port address */
                mess->offset = mess->netno;

                BLOCKPREE();                      /* block task
            switching */
                _outb(tport+IMR, 0x00);                     /* disable
            interrupts */
                if (netp->hwflags)           /* is device idle? */
                {
                    QUEUE_IN(netp, depart, mess); /* no, so add message
            to departure queue */
                    RESUMEPREE();            /* resuem task switching */






                       stat = 0;                /* return and let interrupt
               send it */
                   }
                   else
                   {
                       netp->hwflags = 1;       /* set device busy */
                       RESUMEPREE();            /* resume task switching */

                       < < write message to device and transmit >>

                        stat = 1;
                   }
               _outb(tport+IMR, 0x1f);                     /* enable
               interrupts */
                   return stat;
               }


             Open Connection             Open Connection             _______________


               static int opeN(int conno, char *protoc, int flag)

             Normally no action is needed unless you have special actions
             to take when a connection is opened.  The parameters are an
             index to the open network connection, the protocol path, and a
             flag.  In the WD8003 driver a small amount of code was written
             which used the flag parameter to process a monitoring flag the
             device understood for specifying different kinds of messages
             which could be accepted or rejected.  Refer to WD8003.C if you
             are interested.


             Close Connection             Close Connection             ________________


               static void closE(int conno, char *protoc)

             Normally no action is needed unless you have special actions
             to take when a connection is closed.  As in the opeN(), the
             WD8003 driver used a small amount of code to process the
             monitoring flag.


             Configure and Start Up             Configure and Start Up             ______________________


               static int init(int netno, char *protoc, char *params)

             Init() processes the hardware parameters,  calls the optional
             adapter initialization, sets up the hardware, and stores data
             into the network table.  Then it calls routine IRinstall() to
             store the interrupt address and enable the interrupt.  The
             arguments are network number, protocol path, and






          initialization parameters.  The initialization parameters are
          the same device parameters configured in the network
          configuration table.

          The initialization parameters for the WD8003 are the I/O port
          address, the interrupt number and the shared buffer address.
          Another device might need different parameters.  The example
          below is based on the WD8003 driver.






             Example             _______

               /*=========================================
                  Configure and start up the Ethernet interface.  We
                  process the user-level text parameters and store the
                  values into the net table.  We take the address from the
                  Ethernet board, and set up the board.  Then we store the
                  interrupt address and enable the interrupt.
                  Returns:
                    error:    -1
                    success:   0
               */

               static int init(int netno, PTABLE **protoc, char *params)
               {
                   int i1, ultra, tport;                  /* device I/O
               port address */
                   unsigned long bpar;
                   char cc1, cc2, *cp1, par[16], val[16];      /* for
               parsing and storing parameters */
                   struct NET *netp;                 /* network structure
               */

                   ....
                   netp = &nets[netno];                   /* assign network
               structure */
                   for (cp1=params; *cp1; )                         /* for
               each parameter.... */
                   {
                       Nsscanf(cp1, "%[^=]=%s %n", par, val, &I1);     /*
               parse the parameter */
                       cp1 += i1;
                       if (strcmp(par, "IRNO") == 0)
               /* which param is it? */
                           Nsscanf(val, "%d", &netp->irno[0]);          /*
               assign params to correct*/
                       else if (strcmp(par, "PORT") == 0)               /*
               fields in network structure */
                           Nsscanf(val, "%i", &netp->port);
                       else if (strcmp(par, "BUFFER") == 0)
                       {
                           Nsscanf(val, "%li", &bpar);
                           netp->base[0] = mapioadd(bpar);     /* convert
               to a far ptr from 32 bit */
                       }
                       else return NE_PARAM;                            /*
               return parameter error */
                   }
                   tport = netp->port;                  /* assign device
               I/O port address */
                   netp->bps = 10000000;          /* assign bits per
               second, this is an Ethernet */






                << setup hardware, perform device specific
            initializations >>

                IRinstall(netp->irno[0], netno, irhan);
            /* install interrupt handler */
                ....
            return 0;
            }

          This example does not call the adapter initialization.  To see
          how this is done refer to the init() routine in the character
          driver section.


          Shut Down          Shut Down          _________


            static void shut(int netno, char *protoc)

          The arguments are network number and protocol path.  This
          turns off the controller and calls the optional adapter
          shutdown.  It calls routine IRrestore() to restore original
          interrupt status.

          Example          _______

            /*==========================================
               Shut down the Ethernet interface.  Restores original IRQ,
               mask and vector.
               Turns off the controller.
            */
            static void shut(int netno, PTABLE **protoc)
            {
                int tport;                              /* device I/O
            port address */
                struct NET *netp;                  /* ptr to network
            struct */

                ....
                netp = &nets[netno];              /* assign ptr to
            network struct */
                tport = netp->port;                /* get address of I/O
            port */

                << write shutdown info to device using port I/O address
            >>

                IRrestore(netp->irno[0]);           /* restore the
            original interrupt */
            }

          This example does not call the adapter shutdown.  To see how
          this is done refer to the shut() routine in the character
          driver section.






             Protocol Table             Protocol Table             ______________

             See the section on character drivers for an explanation of the
             protocol table.  It is identical for block drivers.  The
             example here shows an entry for the WD8003 driver.

             Example             _______

               const struct Ptable WD8003_T = {"WD8003", init, shut, 0,
               open, close, 0,
                   write, 0, sizeof(MESS)};

             The field "WD8003" is the name of the driver, all others are
             normally fixed.  Zeros may be used for functions which are not
             used.


             ADAPTERS             ADAPTERS

             A PCMCIA card connects through a PCMCIA adapter as shown here.


                                  +------+                                  +------+
                                   compu                                  |      |                                  |      |
                                   ter                                  |      |                                  |      |
                                  +------+                                  +------+
                                      |                                      |
                                      |                                      |
                                  +-----+                                  +-----+
                                   adap                                  |     |                                  |     |
                                   ter                                  |     |                                  |     |
                                  +-----+                                  +-----+
                                      |                                      |
                                      |                                      |
                                  +------+                                  +------+
                                   PCMIA                                  |      |                                  |      |
                                  |------|                                  |------|
                                  |      |                                  |      |
                                   card                                  |      |                                  |      |
                                  +------+                                  +------+


             The PCMCIA standard defines a set of service calls (card
             services and socket services) that are used to program the
             adapter.  As long as the software uses these services, and
             does not talk directly to the adapter, any PCMCIA card should
             work with any PCMCIA adapter.

             USNET comes with two adapter modules: PCMCIA1 for card
             services, and PCMCIA2 for socket services.  Use the socket
             services if you have a choice.  However, socket services can
             only be used if the card services are not loaded, so, if some
             other part of the system needs the card services, you will
             have to use them with USNET also.







          The adapter code is formatted as a driver, but has only the
          initialization and the shutdown functions.  The following
          picture shows the relationship:


                                              protocol stack


                               init       adapter                   open
                               shut
            close

            read, write

                                                    driver


          In some cases of course the presence of the PCMCIA adapter
          might also affect the read and the write functions.  For
          efficiency reasons, this might require the creation of a
          separate PCMCIA device driver.

          The PCMCIA services may not be available in all cases, for
          instance, if you build your own PCMCIA interface into an
          embedded controller.  In this case the options are:

           (1) You can create your own socket services, and use them
               through PCMCIA2.

           (2) You can create a new adapter module, for instance
               PCMCIA3, that talks directly to your adapter.

           (3) You can create a device driver that handles the PCMCIA
               interface directly.

          The choice mostly depends on how general the solution needs to
          be.

          The adapter concept is of course in no way limited to the
          PCMCIA adapters.









             8.   APPLICATION ROUTINES             8.   APPLICATION ROUTINES             _________________________
             --------------------------------------------------------------

             Some simple applications are provided as examples.


             TFTP, FTP             TFTP, FTP

             TFTP and FTP are file transfer programs, TFTP is implemented
             with UDP and FTP with TCP.  A full FTP implementation will
             actually do almost anything; the USNET version contains only
             the login and the file transfer operations.  The two ends of a
             file transfer are called a client and a server.  The server is                                        _______      _______
             the passive component, which sits and waits for requests.


             Start Server             Start Server             ____________


               int TFTPserv()
               int FTPserv()

             These calls will start the servers.  If you are using a
             multitasker, you will want to start these as tasks.  The
             server never returns.


             Send File             Send File             _________


               int TFTPput(char *host, char *file, int mode)
               int FTPput(char *host, char *file, int mode)

             This call sends a file.  The arguments are:

             host   Name of the server host. The form can be "host" or             host
             "port/host".

             file   Name of the local file to be sent.  You can also             file   
                    specify "inputfile outputfile" in cases where the file
                    should be created under a different name.

             mode   ASCII for a text file, IMAGE for a binary file.             mode   

             The call returns 0 for success, -1 for failure.

             Examples:             ________

               FTPput("XX", "test1", ASCII);              /* test1 => XX */
               FTPput("XX", "t1 /usr/aa/t1", IMAGE);      /* t1 => XX
               /usr/aa */






          Receive File          Receive File          ____________


            int TFTPget(char *host, char *file, int mode)
            int FTPget(char *host, char *file, int mode)

          This call receives a file.  The arguments are:

          host    Name of the server host. The form can be "host" or          host
          "port/host".

          file    Name of the file to be received.  You can also specify          file    
                  "inputfile outputfile" in cases where the file should
                  be created under a different name.

          mode    ASCII for a text file, IMAGE for a binary file.          mode

          The call returns 0 for success, -1 for failure.

          Examples:          ________

               FTPget("XX", "test1", ASCII);           /* test1 <= XX */
               FTPget("XX", "t1 \tmp\t1", IMAGE);      /* \tmp\t1 <= XX
            t1 */



          BOOTP          BOOTP          _____

          BOOTP uses the UDP protocol to load a program over the
          network.  There are two parts to it: the boot name server
          (which is really not needed in a small network), and the
          bootload code itself, which loads a file using UDP.  USNET
          contains the following BOOTP support routines:


          Get Boot Names          Get Boot Names          ______________


            int BOOTPnames(char *host, char *file)

          The argument host will on return contain the name of the                       ____
          bootload host.  Argument file is the name of the file from                                                                           ____
          which we want to boot.

          The function returns 0 if it is successful, -1 otherwise.


          Load Program          Load Program          ____________


            void FAR *BOOTP(char FAR *base, char *host, char *file)






             This function loads the program in file at host into memory at                                                ____    ____
             address base, and returns the entry address.  The return is 0                     ____
             if the load fails.  The host must be running a TFTP server and
             a bootp server.

             How a binary load file is interpreted is highly system-
             dependent, so BOOTP is not a general routine at all.  The
             USNET version loads a DOS executable.


             Start Server             Start Server             ____________


               void BOOTPserv()

             A call to this starts the boot server.  If you have a
             multitasker, you will want to start BOOTPserv as a task.
             USNET supplies a very simple version that just checks if the
             specified file exists.  A more sophisticated boot server
             might, for instance, determine which executable file should be
             used to load this host.

             Generally, in the remote boot process, both bootp and tftp
             servers are required with bootp establishing the initial
             connection and name resolution and tftp being used to transfer
             the binary file.  The bootp client initiates the whole
             process.  It essentially broadcasts a message to the network
             and expects a response from any bootp server that can respond
             to it.









             9.   TELNET             9.   TELNET             ___________
             --------------------------------------------------------------

             Telnet is the usual TCP/IP method of remote terminal access.
             The client part of Telnet acts as a terminal emulator.  The
             server part depends quite a bit on the circumstances, but is
             usually a command processor with remote login added.  The
             following picture shows this relationship:


                     remote
               local
                     terminal
               terminal

                      Telnet
               Telnet         terminal
                       client
               server         driver


               command shell


             The USNET Telnet is packaged as two main programs: client
             TELNET and server TNSERV.  You may want to make these into
             tasks, see FTP or TFTP for this.  To run the server under UNIX
             or DOS, use the command

                       tnserv

             To run the client under UNIX or DOS, type

                       telnet <target name>

             As supplied, Alt-X terminates the program.  Change variables
             ESCNAME and ESCTYPE if you require a different termination
             character.

             USNET is not tied to any specific operating system, so there
             is no defined command shell.  The supplied Telnet server
             performs only the following functions:

             - It exchanges some basic control information with the
               server.

             - It reads command lines, and calls routine command for                                                         _______
               each.  The routine as supplied just echoes the command.






          The Telnet client (terminal emulator) as supplied is able to
          log on to a UNIX computer, and to perform other similar tasks.
          However, it is not complete yet.









             10.  TEST PROGRAMS             10.  TEST PROGRAMS             __________________
             --------------------------------------------------------------

             Several test programs are included as application examples and
             for verifying proper operation of USNET.


             PING             PING

             PING is an application that uses the ICMP protocol to report
             if a host is responding.  USNET contains PING as an ANSI C
             application.  To run the application, type

                       PING <host>

             The program will report at one-second intervals, until you
             press the escape key.  Note there must be a server process
             running at the remote host.  Test program FTTEST (see below)
             will serve in this manner.  You may also ping a UNIX machine
             with the standard TCP/IP daemons running.


             FTTEST             FTTEST

             FTTEST uses either the FTP or the TFTP protocol to check the
             reliability of the connection.  It runs in one host as a
             server, and in another as a client.  To start the server, type

                       FTTEST
                       FTTEST -UDP

             To get the test running, type at another host

                       FTTEST <host>
                       FTTEST -UDP <host>

             The -UDP flag specifies the TFTP (and therefore, UDP)
             protocol.  The test will run until stopped with the escape
             key, or until there is an error.

             Because FTTEST uses ANSI C stream I/O, it may not run in your
             embedded system.  However, just sending messages between two
             tasks is not a particularly good reliability test.  In these
             matters, the dirtier the better.  An excellent test is to
             configure FTTEST to use a 38,400 bps serial line between two
             PCs.  The DOS disk I/O will make sure that plenty of data is
             lost, and there are lots of retries.  If the test runs
             overnight under these conditions, then you can trust that your
             application will not wither away at the first sign of network
             trouble.






          The FTTEST server does not have a key sequence for quitting
          and will require you to reboot your system to exit when run on
          a PC.  The code was written this way with embedded boards in
          mind.  You may get around this if you run the server process
          in an interactive debugger.


          EMTEST          EMTEST

          EMTEST performs the client function of FTTEST, but using
          simulated file I/O.  It can thus be used to test TCP or UDP in
          a truly embedded system.  However, it needs a server to talk
          to; you cannot have two EMTESTs talking to each other.  EMTEST
          can talk to a UNIX FTP server, or you can bring up a version
          of FTTEST in a DOS system as a server.

          As delivered, EMTEST talks to host "test".  Edit EMTEST.C
          (change the #define SERVER statement) if you need to change
          this.  Edit LOCAL.H if you need to change the login userid or
          password.


          SOTEST          SOTEST

          SOTEST uses both the UDP and the TCP protocol to check various
          BSD socket functions.  It is quite simple, and you may want to
          modify it to test your particular application.  SOTEST is used
          in the same way as FTTEST: it runs in one host as a server,
          and in another as a client.  To start the server, type

                    SOTEST

          To get the test running, type at another host

                    SOTEST <host>

          The test will run until stopped with the escape key, or until
          there is an error.  The server process will not exit without
          rebooting the system.  See FTTEST above for more information.


          MTTEST          MTTEST

          MTTEST is a simple and heavy multitasking test.  You run it in
          two hosts, it consists of two tasks that communicate as shown
          by this picture:

                    CLIENT HOST                       SERVER HOST

                      task 1 write                             task 2
            read
                      task 2 read                              task 1
            write








             The protocol used is TCP.  The tasks are reading and writing
             full speed doing no waiting or checking.  (The read tasks do
             check the data though.)  The test will very quickly find out
             if there is something wrong with the multitasking support.  It
             is also a good test of the TCP flow control, because it
             overloads just about any data link you can give it.

             To start the server, type

                       MTTEST

             To get the test running, type at another host

                       MTTEST <host>

             The test will run until stopped with the escape key, or until
             there is an error.

             As delivered, MTTEST is written for the US Software
             MultiTask!.  It will need some small changes for any other
             multitasker, and of course you need to configure the
             multitasking support in the header file SUPPORT.H.

             MTTEST as provided is for DOS, but you can run it in an
             embedded controller by coding the host name (needed by the
             client) into the program.









             11.  ADDING AND CHANGING PROTOCOLS             11.  ADDING AND CHANGING PROTOCOLS             __________________________________

             -----------------------------------------------------------             -----------------------------------------------------------

             To define to USNET a new protocol, proceed as follows:

             - Give the protocol a name, define this in NET.H equal to the
               next unused protocol number.  We will assume here that the
               name is "newprot".

             - Add to NET.C the declaration:

                       extern struct Ptable newprot_T

             - Add to NET.C in table Ptable the entry &newprot_T.  This                                                      __________
               will go into the second to last position, before the
               terminating 0.

             - Create module NEWPROT.C starting with the existing USNET
               module that is most similar to yours.

             All protocol modules must follow the same physical structure.
             The skeleton shown below follows for the most part the TCP
             logic, though many details are left out.  The ACK queue
             mentioned there is used as follows:

             - The writE() routine will queue any message that needs to be
             acknowledged.

             - Whenever screen() sees an arrived acknowledgment, it will
               scan the ACK queue and remove all messages that were
               acknowledged.

             - The network task will periodically check the ACK queues for
               overdue responses.  It will resend as necessary, and set an
               error status if this did not help.


             The future queue (the out-of-order queue) is handled as
             follows:

             - When screen() sees a future message, it enters this into the
               future queue, sorted by ascending sequence number.

             - Whenever screen() returns to the network task with a status
               meaning "message accepted", the network task checks the
               future queue.  If this is not empty, it calls screen() with
               the first future message.






            /* ============================================
               Open function.  Call next level. */

            static int opeN(int conno, char *protoc, int flags)
            {
                int i1;
                i1 = Ptable[protoc[1]]->open(conno, protoc+1, flags);
                if (i1 < 0)
               return i1;
                << open processing >>
                return i1;
            }

            /*============================================
               Close function, just call next level. */

            static void closE(int conno, char *protoc)
            {
                Ptable[protoc[1]]->close(conno, protoc+1);
            }

            /*============================================
               Screening function, checks the coming message.  Searches
            the connection
               tables for one that is open for the right port.  Return:
               -5  processed, release message buffer, check out-of-order
            queue
               -4  message queued, do not release
               -2  processed, release message buffer
               -1  error occurred
               n   user data, please enter in queue number n
            */

            static int screen(MESS *mess)
            {
                int conno;
                << find the connection table -> conno >>
                << check the message >>
                << if error return -1 >>
                << if future (out of order), queue and return -4 >>
                << if control message process and return -2 or -5 >>
                << if ACK process the ACK queue >>
                return conno;
            }






               /*============================================
                  Read routine.  Calls the lower level read, gives the
               caller the message.
                  Returns:
                  success: message address
                  error:   0
               */

               static MESS *reaD(int conno, char *protoc)
               {
                   MESS *mp;
                   mp = Ptable[protoc[1]]->read(conno, protoc+1);
                   if (mp == 0)
                  return mp;
                   << process message >>
                   return mp;
               }

               /*============================================
                  Write routine.  Creates a header and calls the lower-
               level write.  Returns:
                   n  done, n characters sent
                   0  pending, message queued to wait for ack
                  -1  error
               */

               static int writE(int conno, char *protoc, MESS *mess)
               {
                   int stat;
                   << create header >>
                   stat = Ptable[protoc[1]]->write(conno, protoc+1, mess);
                   if (stat < 0)
                       return stat;
                   << if ACK needed queue message into the ACK queue,
               return 0 >>
                   return stat;
               }

               /*============================================
                  Protocol table for newprot. */

                  const struct Ptable newprot_T = {"newprot", 0, 0, screen,
                  opeN, closE,
                      reaD, writE, 0, sizeof(struct Nhdr)};









             12.  BSD SOCKET INTERFACE             12.  BSD SOCKET INTERFACE             _________________________
             --------------------------------------------------------------



             ABOUT BSD SOCKETS             ABOUT BSD SOCKETS

             The BSD 4.3 sockets are the closest thing there is to a
             standard user interface to TCP/IP.  However, they can only be
             approximated on a non-UNIX system, because a great many UNIX
             functions interact with sockets.

             USNET supports all BSD 4.3 socket specific functions (though
             not all features of these), plus the use of read(), write(),
             close() and select().  The select is not a complete UNIX
             select implementation (see the section on select() later in
             this chapter).  The use of signals, fcntl() and iocntl() for
             sockets is not included.


             USING BSD SOCKETS             USING BSD SOCKETS

             The socket interface requires a number of different function
             calls.  The USNET socket calls are described here along with
             examples.  As in any socket application, the client and server
             use a different set of function calls.  This is described in
             the following pages.


             Structures and Definitions             Structures and Definitions             __________________________

             The socket functions require internet addresses and port
             numbers to be passed via a sockaddr structure.  The sockaddr
             structure is a generic structure which accepts a number of
             different communications protocols.  USNET uses only the
             internet protocol (IP) and therefore only requires the use of
             the internet structure sockaddr_in.  Values are assigned to                                    ___________
             sockaddr_in and passed into the socket routine via the
             sockaddr parameter.  This requires a typecast to a sockaddr*.
             See the example given for the connect() function for an
             illustration of this point.

             To include the socket definitions use the following #include.

               #include "socket.h"






          The sockaddr structure is defined as follows.

            struct sockaddr {      /* generic socket address
            */
                unsigned short sa_family;    /* address family
            */
                char sa_data[14];  /* up to 14 bytes of direct address
            */
            };

          As was just mentioned, this is not actually used by the
          application, but rather is a generic type used for parameter
          passing.  For USNET's purposes it is simply here for
          consistency with the standard socket interface.  The actual
          structure to be passed in to a socket call is sockaddr_in.

            struct in_addr {            /* Internet address */
                unsigned long S_addr;
            };
            struct sockaddr_in {        /* Internet socket address */
                short sin_family;
                unsigned short sin_port;
                struct in_addr sin_addr;
                char sin_zero[8];
            };

          This structure would be assigned values and then typecast tp a
          sockaddr* when being passed to a socket function.  Again,
          refer to the example for connect().


          Creating a socket          Creating a socket          _________________

          Socket() is the BSD call to create a socket.  A socket must
          first be created before any other socket calls are used.  This
          routine returns an integer value used as an identifier for the
          created socket.  Socket() is the initialization routine which
          both client and server must perform.  The syntax is

            int socket(int domain, int type, int protocol);

          In USNET, the domain parameter is

               PF_INET        TCP/IP and related

          The socket type values are:

                         SOCK_STREAM    stream socket = TCP/IP
                         SOCK_DGRAM     datagram socket = UDP/IP
                         SOCK_RAW       raw-protocol interface = link
            layer

          The third parameter is not used by USNET.  The return value is
          the socket number for success or -1 for failure.







             Example             _______

               int s;                 /* a socket            */
               ....
               s = socket(PF_INET, SOCK_DGRAM, 0);               s = socket(PF_INET, SOCK_DGRAM, 0);
               if (s < 0)
                  printf("Error opening socket\n");
               ....

             This example would be a UDP socket since the type parameter is                                                          ____
             SOCK_DGRAM.


             Initiate a Connection On a Socket             Initiate a Connection On a Socket             _________________________________

             Use the connect() call to perform an active client open and
             establish a connection with a remote server.  This is the BSD
             routine to do an active open for a connection.

               int connect(int s, struct sockaddr *name, int namelen);

             The parameters are

               s        identifier of a socket previously created with the
             socket() call.
               name     structure to identify the remote host to connect
             to.
               namelen  size of "name".

             The socket must already have been created.  The name structure                                                             ____
             is used to specify the port number and the Internet address of
             the remote host.  The internet address is usually retrieved
             using gethostbyname().  See the section on this function for
             specifics.

             The return value is 0 for success, -1 for error.

             Example             _______

               int rc;                  /* return code
               */
               struct sockaddr_in socka;   /* internet address and port
               number */
               ....
               memset(&socka, 0, sizeof(socka));
               socka.sin_family = AF_INET;
               rc = gethostbyname("host1", &socka);
               socka.sin_port = 69;
               rc = connect(s, (struct sockaddr *)&socka, sizeof(socka));               rc = connect(s, (struct sockaddr *)&socka, sizeof(socka));
               if (rc < 0)
                  printf("Error connecting to remote server\n");






          Here you can see &socka which is of type sockaddr_in* must be
          cast to a sockaddr* since this is what is expected by
          connect().  This refers back to the previous discussion on
          structures and definitions.


          Bind a Name To a Socket          Bind a Name To a Socket          _______________________

          Bind is required by a server to specify the local port number
          and local Internet address of a connection.  This defines the
          port number the server is listening to.  The socket must
          already have been created with a socket() call.  Bind() is
          required before a server accept() call.  It is not required
          (but can be used) before a connect().

            int bind(int s, struct sockaddr *name, int namelen);

          The parameters are the same as for the connect.

          The return value is 0 for success, -1 for error.

          Example          _______

            int rc;                /* return code       */
            int s;                 /* socket identifier */
            struct sockaddr_in socka;        /* local port, etc    */
            ....
            memset(&socka, 0, sizeof(socka));
            socka.sin_family = AF_INET;
            socka.sin_port = 69;
            rc = bind(s, (struct sockaddr *)&socka, sizeof(socka));            rc = bind(s, (struct sockaddr *)&socka, sizeof(socka));
            if (rc < 0)
               printf("bind\n");

          In this example, 69 is the local port to be used.  A client
          performing a connect to this server would also use the
          portnumber 69.


          Listen For Connections          Listen For Connections          ______________________

          The BSD routine for specifying a passive open will be done is
          listen().  Listen() just records the fact; no other work is
          actually done.  It is called after the bind() and before an
          accept() within a server application.

            int listen(int s, int backlog);

          Parameter s is the socket identifier.  USNET does not use the                    _
          backlog argument.






             Example             _______

               int rc;      /* return code       */
               int s;       /* socket identifier */
               ....
               rc = listen(s, 0);               rc = listen(s, 0);
               if (rc < 0)
                  printf("Error calling listen\n");


             Accept Connection On a Socket             Accept Connection On a Socket             _____________________________


               int accept(int s, struct sockaddr *name, int namelen);

             The accept() call performs a server (passive) open for a
             created and bound socket.  It remains in a wait state until a
             client runs a connect against the port accept() is listening
             to.  Recall bind() determined that port number.  Then,
             accept() returns with a new socket.  The original socket is
             not changed in any way.  The new socket is used for reads and
             writes, with the original being retained for connections by
             other clients.  This concept of using two sockets may be used
             by a server to process requests from multiple clients
             simultaneously.  See the section on using multitasking for
             serving multiple clients for more information.

             The parameters are the same as for connect() and bind().
             Here, though, name and namelen return the sockaddr information                           ____     _______
             for the connecting client.  The return value is socket number
             for success, -1 for error.

             Example             _______

               struct sockaddr_in socka;
               ....
               memset(&socka, 0, sizeof(socka));          /* clear socka of
               any previous values */
               socka.sin_family = AF_INET;
               s2 = accept(s, (struct sockaddr *)&socka, sizeof(socka));               s2 = accept(s, (struct sockaddr *)&socka, sizeof(socka));
               if (s2 < 0)
                  printf("Error, accept did not return a valid socket.\n");


             Receive a Message             Receive a Message             _________________

             There are three BSD routines to receive a message from a
             socket.  The recv() version is used for an open connection,
             the other two can be used even if no connection has been
             established and will then establish the connection for you
             before reading.






            int recv(int s, char *buf, int len, int flags);
            int recvfrom(int s, char *buf, int len, int flags, struct
            sockaddr *from, int *fromlen);
            int recvmsg(int s, struct msghdr *msg, int flags);

          USNET does not currently support the flags argument.

          Recvmsg() requires the msghdr structure which has the
          following form:

            struct msghdr {        /* Message header for recvmsg and
            sendmsg. */
                char *msg_name;    /* optional address
            */
                int msg_namelen;   /* size of address
            */
                struct iovec *msg_iov;  /* scatter/gather array
            */
                int msg_iovlen;    /* # elements in msg_iov
            */
                char *msg_accrights;    /* access rights sent/received
            */
                int msg_accrightslen;
            };
            struct iovec {         /* address and length
            */
                char *iov_base;    /* base
            */
                int iov_len;       /* size
            */
            };

          USNET ignores the access rights in the msghdr structure.

          The return value is number of bytes received for success, -1
          for error.

          Examples          ________

          The recv function would be used as follows

            int rc;                     /* return code        */
            int s1 ,s2;                 /* socket identifiers */
            unsigned char buff[BUFFLEN];     /* read buffer */
            ....
            s2 = accept(s1, (struct sockaddr *)&socka, sizeof(socka));
            ....
            rc = recv(s2, buff, 2, 0);            rc = recv(s2, buff, 2, 0);
            if (rc < 0)
               printf("Error receiving data.\n");
            else if (rc == 2)
               printf("Success: read 2 bytes\n");
            else
               printf("Error: read did not retrieve 2 bytes.\n");







             Notice in this example recv() uses the second socket
             identifier, the one returned from the accept(), not the
             original socket which is used as an argument to accept().

             As mentioned above, recvfrom() may be used to establish a
             connection and perform a read.  A sockaddr structure is used
             to determine the remote host to connect to.

               int s1, s2;            /* socket identifiers
               */
               int rc;                /* return code
               */
               unsigned char buff[BUFFLEN];     /* read buffer
               */
               struct sockaddr_in socka;   /* remote host internet address
               */
               ....
               memset(&socka, 0, sizeof(socka));
               socka.sin_family = AF_INET;
               rc = gethostbyname("host1", &socka);
               socka.sin_port = 69;
               rc = recvfrom(s2, buff, 8, 0, (struct sockaddr *)&socka,               rc = recvfrom(s2, buff, 8, 0, (struct sockaddr *)&socka,
               sizeof(socka));               sizeof(socka));
               if (rc != 8)
                  printf("Error recvfrom did not retrieve 8 bytes.\n");

             The accept() or connect() call is not needed here since
             recvfrom() performs the connection.  This would be considered
             a client connect operation to be performed against a remote
             server's accept() call.  GethostbyName() is used to retrieve
             the internet address of the remote host and will be explained
             later in this chapter.

             Recvmsg() may also be used to establish a connection and a
             read with one routine.  This is the most general of the three
             read routines.  It is used similarly to readfrom().  The
             structure msghdr allows a number of options such as access
             rights to be used with readmsg().  Refer to a text on socket
             programming for more information if you require the use of
             recvmsg().


             Send a Message             Send a Message             ______________

             The BSD routines to send a message to a socket are analogous
             to reading messages.  The send() version is used for an open
             connection, the other two can be used if no connection has
             been established.

               int send(int s, char *buf, int len, int flags);
               int sendto(int s, char *buf, int len, int flags, struct
               sockaddr *to, int tolen);
               int sendmsg(int s, struct msghdr *msg, int flags);







          USNET does not currently support the flags argument.  See the                                               _____
          receive functions for the msghdr structure definition.

          The return value is the number of bytes sent for success, -1
          for failure.

          Examples          ________

            int s2;                /* socket identifier */
            int rc;                /* return code       */
            unsigned char buff[BUFFLEN];     /* send buffer       */
            ....
            rc = send(s2, buffer, sizeof(buffer), 0);            rc = send(s2, buffer, sizeof(buffer), 0);
            if (rc < 0)
               Nprintf("Error sending data.\n");

          As in the case of recv(), send() expects a connection to
          already have been established.  Either an accept() or
          connect() must have occurred previously.  If this is not the
          case, sendto() may be used to set up a connection as was done
          with readfrom().

            rc = sendto(s, "HIJKLMNO", 8, 0, (struct sockaddr *)&socka,            rc = sendto(s, "HIJKLMNO", 8, 0, (struct sockaddr *)&socka,
            sizeof(socka));            sizeof(socka));
            if (rc < 0)
               printf("Error sending to remote host.\n");

          Here, we send a string passed in directly rather than using a
          buffer.  This could also be done in send().  Remember the
          parameter is simply a char*.  The declarations are left out of
          this example since they are similar to recvfrom().  Sendmsg()
          is analogous to recvmsg().  Again, refer to a socket
          programming text for the use of sendmsg().


          Shut Down Part of Connection          Shut Down Part of Connection          ____________________________


            int shutdown(int s, int how);

          This call will do nothing in USNET and is provided simply for
          portability to other socket implementations.


          Close, Read, Write          Close, Read, Write          __________________

          Close(), read(), and write() are supported by USNET simply as
          macro definitions.  These are general UNIX routines which can
          be used for sockets as well as for files.  If you use them for
          I/O other than sockets, delete the above definitions from
          socket.h, and for socket operations use directly the forms
          closesocket(), Nread(), and Nwrite() instead.






               #define close(s) Nclose(s)
               #define read(s, buff, len) Nread(s, buff, len)
               #define write(s, buff, len) Nwrite(s, buff, len)

             Example             _______

               int rc;             /* return code */
               int s1;             /* socket identifier */
               ....
               rc = close(s1);               rc = close(s1);

             Read() and write() are used similarly to recv() and send()
             minus the flags parameter.  Recall this parameter is not used
             by USNET anyway.


             Get Host By Name             Get Host By Name             ________________


               int gethostbyname(char *name, struct sockaddr *sa);

             This routine retrieves the internet address of a host given
             its hostname.  The parameter name is normally "hostname", but                                          ____
             "portname/hostname" can be used when you want to talk using a
             specific port or network connection.  The parameter sa                                                                 __
             contains the returned internet address and port number.

             An index into the network configuration table is returned, or,
             if no entry is found, -1 is returned.

             NOTE: the BSD definition is different, and unsuitable for
             embedded environments.

             Example             _______

               struct sockaddr_in socka;
               int rc;
               ....
               memset(&socka, 0, sizeof(socka));
               socka.sin_family = AF_INET;
               rc = gethostbyname("com1/host1", &socka);               rc = gethostbyname("com1/host1", &socka);
               if (rc < 0)
                  Nprintf("%s not known\n", hnp);

             The socka structure would now contain the remote host's
             internet address information assuming gethostbyname() returned
             successfully.


             Get Socket Name             Get Socket Name             _______________

             This routine retrieves the local Internet address and the port
             number into a sockaddr structure given a socket identifier.






            int getsockname(int s, struct sockaddr *name, int *namelen);            int getsockname(int s, struct sockaddr *name, int *namelen);

          The parameters are the socket identifier and the sockaddr
          structure (plus its length) to contain the returned
          information.  The return value is 0 for success, -1 for error.

          Example          _______

            struct sockaddr_in socka;
            int rc;                /* return value */
            int s;                 /* socket identifier */
            ....
            s = socket(PF_INET, SOCK_DGRAM, 0);

            ....
            rc = getsockname(s, (struct sockaddr *)&socka,            rc = getsockname(s, (struct sockaddr *)&socka,
            sizeof(socka));            sizeof(socka));
            if (rc < 0)
               Nprintf("Error in getsockname \n");

          If getsockname() returns successfully, socka will now contain
          the local internet address and port number for the given
          socket connection.



          Get and Set Options On Sockets          Get and Set Options On Sockets          ______________________________

          USNET supports some of the BSD socket options using
          getsockopt() and setsockopt().  These are used to manipulate
          socket options.

            int getsockopt(int s, int level, int optname, char *optval,
            int *optlen);
            int setsockopt(int s, int level, int optname, char *optval,
            int *optlen);

          The parameters are socket identifier, option level (only
          SOL_SOCKET is supported), option name (see the list below),
          option value (returned value or value to set depending on the
          routine), and option length.  The return value is 0 for
          success, -1 for error.

          USNET supports only the following option names:

            SO_SNDBUF         send buffer size
            SO_RCVBUF         receive buffer size
            SO_ERROR:         get error status and clear
            SO_TYPE:          get socket type






             Example             _______

               int inc_buff;            /* value to increase socket buffer
               by */
               ....
               inc_buff = 16364;
               ....
               rc = setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char*) inc_buff,               rc = setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char*) inc_buff,
               sizeof(inc_buff) );               sizeof(inc_buff) );
               if (rc < 0)
                  Nprintf("Error in setsockopt \n");

             This is just one example of many which could be shown.  In
             this example we use setsockopt() to increase the internal
             socket buffer size.  A scenario for doing this might be to
             improve performance.  Although the fourth parameter expects a
             char*, most of the option values to be passed in are integers
             which must be typecast.  As for USNET, all the supported
             options are integers; nevertheless, the char* argument is
             still expected for compatibility with standard socket
             implementations.  Therefore, the cast to a char* is required.


             Select             Select             ______

             Select() can be used to wait for a message from any of several
             sockets.  The structure fd_set specifies which sockets (range
             0-nfds) are considered.  This is a general UNIX routine that
             handles sockets as well as files.  The USNET version operates
             only on sockets.  If you use the UNIX select for purposes
             other than reading sockets, rename this function to Nselect().
             USNET does not assume that the operating system supports a
             select operation, and performs this call using polling and
             short sleeps.  Parameter exceptfds is not used by USNET and                                      _________
             must be zero or an error is returned.

               int select(int nfds, fd_set *readfds, fd_set *writefds,                                      _                _
               fd_set *exceptfds,                 _
                       struct timeval *timeout);

             The parameters are

               nfds     number of sockets (UNIX calls it file descriptors).               ____
               readfds  socket numbers to wait on for an arrived message.               _______
               writefds socket numbers to check if there is a connection               ________
             open.
               exceptfds    not used by USNET, provided for compatibility               _________
             reasons only.
               timeoutl determines timeout value.               ________

             When select() returns, readfds contains only those sockets
             that have an arrived message.  Writefds contains only those
             sockets which currently have an open connection.  The return






          value is -1 for error, 0 for timeout, or number of ready
          sockets for success.

          The following macros can be used to manipulate fd_set:

            FD_ZERO(&fd_set)  clear the socket list
            FD_SET(s, &fd_set)     add socket s
            FD_CLR(s, &fd_set)     remove socket s
            FD_ISSET(s, &fd_set)   non-zero if s included

          Structure timeval is used to pass in the timeout value:                    _______

            struct timeval {   /* Timeout format for select() */
                long tv_sec;   /* seconds */
                long tv_usec;  /* microseconds */
            };

          Passing in a zero pointer for the timeout value gives an
          infinite timeout.

          Example          _______

            int s1, s2, s3;             /* sockets      */
            int rc;                /* return code */
            fd_set  socket_set1, socket_set2;
            ....
            FD_SET(s1, &socket_set1);
            FD_SET(s3, &socket_set1);
            FD_SET(s2, &socket_set2);
            rc = select(3, socket_set1, socket_set2, 0, NULL);            rc = select(3, socket_set1, socket_set2, 0, NULL);
            if (rc < 0)
               printf("Error, no sockets ready.\n");
            else
               printf("%d number of sockets have a ready message.\n",
            rc);

          FD_SET() adds sockets, s1, and s3 to the fd_set structure                                 __      __
          socket_set1.  This is passed in to select() for the readfds          ___________
          parameter.  Therefore, sockets s1 and s3 are checked for
          arrived messages.  The writefds parameter gets the fd_set
          socket_set2, which only has one socket (s2) as a member.  In          ___________                             __
          USNET, this tests socket s2 for an open connection.  Parameter
          exceptfds is not used by USNET.  The timeval parameter is NULL
          which gives an infinite timeout value.  The return value in
          this case gives the number of sockets that either have a
          message waiting or have an open connection.  This is an
          impractical example in that an application would probably want
          one or the other but not both simultaneously.  Generally, an
          application would use only one of the two fields, readfds and
          writefds, at a time.






             A COMPLETE CLIENT-SERVER EXAMPLE             A COMPLETE CLIENT-SERVER EXAMPLE

             Up to this point, this chapter has presented the USNET socket
             interface along with isolated examples.  Here we will show how
             all these calls work together by providing a simple but
             complete client server example.






          Server          ______

            void main()
            {
               int rc;                  /* return code         */
               int s1, s2;              /* socket identifiers  */
               unsigned char buff[BUFF_SZ];  /* data buffer          */
               struct sockaddr_in socka, sockb;   /* port & IP address
               */

               if (Ninit-() < 0)        /* initialize USNET */
                    return -1;

               /* assign values to sockaddr_in (internet sock addr
               structure)       */
               memset(&socka, 0, sizeof(socka));                 /*
               clear socka before using */
               socka.sin_family = AF_INET;                       /*
               assign internet family */
               socka.sin_port = 69;     /* assign port number */

               /* create a stream socket */
               s1 = socket(PF_INET, SOCK_STREAM, 0);
               if (s1 < 0)
                    Nprintf("Error: creating socket\n");

               /* required before an accept, initializes port number */
               rc = bind(s1, (struct sockaddr *)&socka, sizeof(socka));
               if (rc < 0)
                    Nprintf("bind\n");

               /* records that a passive open will be done */
               rc = listen(s1, 10);
               if (rc < 0)
                    Nprintf("Error: listen\n");

               /* accept a connection and use a new socket, s2 for the
               connection.       */
               /* connecting client's internet address and port number
               returned in sockb */
               memset(&sockb, 0, sizeof(sockb));
               sockb.sin_family = AF_INET;
               s2 = accept(s1, (struct sockaddr *)&sockb,
               sizeof(sockb));
               if (s2 < 0)
                    Nprintf("Error: accepting a connection.\n");
               /* receive three bytes of data from client and print them
               */
               rc = recv(s2, buff, 3, 0);
               if (rc == 3)
                    Nprintf("%c%c%c\n",buff[0], buff[1], buff[2]);
               else
                    Nprintf("Error: recv\n");






                  /* close sockets */
                  rc = close(s1);
                  if (rc < 0)
                       Nprintf("Error: closing socket #1.\n");
                  rc = close(s2);
                  if (rc < 0)
                       Nprintf("Error: closing socket #2.\n");

               }  /* end main--server */






          Client          ______

            void main()
            {
            int rc;                     /* return code         */
            int s1;                     /* socket identifier   */
            unsigned char buff[BUFF_SZ];     /* data buffer          */
            struct sockaddr_in socka;   /* port & IP address */

            memset(&socka, 0, sizeof(socka));
            socka.sin_family = AF_INET;

            /* create a stream socket */
            s1 = socket(PF_INET, SOCK_STREAM, 0);
            if (s1 < 0)
               Nprintf("Error: creating socket\n");

            /* load remote host address into socka, also assign port
            number */
            rc = gethostbyname("host1", &socka);
            if (rc < 0)
               Nprintf("Error: gethostbyname\n");
            socka.sin_port = 69;

            /* create a connection to remote server */
            rc = connect(s1, (struct sockaddr *)&socka, sizeof(socka));
            if (rc < 0)
            {
               Nprintf("Error: opening connection.\n");
               exit(0);
            }
            else
               Nprintf("Connect successful.\n");

            /* send some data */
            buff[0] = 'W';
            buff[1] = 'O';
            buff[2] = 'W';

            /* send data */
            send(s1, buff, 3, 0);

            /* close socket connection */
            rc = close(s1);
            if (rc < 0)
               Nprintf("Error: closing socket\n");

            }  /* end main--client */


          Using multitasking to serve multiple clients          Using multitasking to serve multiple clients          ____________________________________________

          If you are using a multitasker, you can write your server
          application to accept connections from multiple clients at a






             time.  This is because accept() returns a new socket to be
             used for sending and receiving data, leaving the old one
             available to accept a connection from an additional client.
             If multitasking is available, after the accept() the server
             can create a new task to exchange data with the client, and
             the parent task can sit in a loop which returns to the accept,
             waiting for a new client connect.  The end result is that all
             client-server data transmission is performed by children, or
             subtasks, of the parent task.  This is a fairly classic
             algorithm which may be found in many data communications
             texts.  The example below shows how this would be done using
             USNET's RUNTASK() macro for the task creation.  In this
             example much of the extraneous code such as error checking has
             been removed for clarity.  The main point here is the loop
             with the RUNTASK macro.

               void main()
               {
                  int rc;                  /* return code         */
                  int s1, s2;              /* socket identifiers  */
                  struct sockaddr_in socka, sockb;   /* port & IP address
                  */

                  if (Ninit() < 0)         /* initialize USNET */
                       return -1;

                  /* assign values to internet address structure */
                  socka.sin_family = AF_INET;                       /*
                  assign internet family */
                  socka.sin_port = 69;     /* assign port number    */

                  /* create a stream socket */
                  s1 = socket(PF_INET, SOCK_STREAM, 0);
                  rc = bind(s1, (struct sockaddr *)&socka, sizeof(socka));
                  rc = listen(s1, 10);

                  /* loop forever accepting connections, accept a
                  connection and use a new socket,
                       s2, for the connection, start a new task to get
                  data. */
                  while(1)
                  {
                       memset(&sockb, 0, sizeof(sockb));
                       sockb.sin_family = AF_INET;
                       s2 = accept(s1, (struct sockaddr *)&sockb,
                       sizeof(sockb));
                       if (s2 < 0)
                            Nprintf("Error: accepting a connection.\n");
                       else
                            RUNTASK(getdata, 0, &s2)                            RUNTASK(getdata, 0, &s2)
                  } /* end while */

               }  /* end main--server */






            /* getdata() is a child task run from the server.  It
            transmits data to a
                client after a connection has been established by the
            parent task.
                Argument is the socket to send data to.
            */

            TASKFUNCTION getdata(int* sockptr)
            {
               int rc;                             /* return code */
               int s;                              /* socket        */
               unsigned char *buff[3];    /* data buffer  */

               s = *sockptr;
               /* receive three bytes of data from client and print them
               */
               rc = recv(s, buff, 3, 0);
               if (rc == 3)
                    Nprintf("%c%c%c\n",buff[0], buff[1], buff[2]);
               else
                    Nprintf("Error: recv\n");

               /* close socket */
               rc = close(s);
               if (rc < 0)
                    Nprintf("Error: closing socket.\n");

            } /* end senddata */

          RUNTASK() would cause a new task to be generated each time the
          accept() successfully returns a client connection.  These new
          tasks handle the receiving of data from the client while the
          parent loops back, resets sockb, and calls accept(), waiting
          for another client.

          If multitasking is not available, then obviously, we cannot
          use separate tasks to handle data transmission.  In contrast
          to the above example, below is an example of a server's loop
          in a non-multitasking environment.






                  /* loop forever accepting connections, accept a
                  connection and use a new socket,
                       s2 for the connection, process client before
                  accepting a new client connection.
                  */
                  while(1)
                  {
                       memset(&sockb, 0, sizeof(sockb));
                       sockb.sin_family = AF_INET;
                       s2 = accept(s1, (struct sockaddr *)&sockb,
                       sizeof(sockb));
                       if (s2 < 0)
                            Nprintf("Error: accepting a connection.\n");
                       else
                            getdata(&s2);
                  }  /* end while */

             Here, you can see only one client may be processed at a time.
             Due to the sequential execution of the non multitasking
             system, getdata() must run before any new client connections
             can be accepted.









             13.  PERFORMANCE             13.  PERFORMANCE             ________________

             -----------------------------------------------------------             -----------------------------------------------------------

             Ethernet runs at 10 million bits per second.  Some overhead is
             unavoidable, but a good Ethernet controller can still handle 1
             million bytes per second.  In practice, the rate is limited by
             the following factors:

             - Protocol stack overhead: passing the message from one level
             to another.

             - Flow control, error checking, recovery, control information.

             - The production and consumption of the data in the
             application.

             - Overhead in interrupts, task switches and the like.

             Expecting over 500,000 bytes per second from Ethernet is not
             realistic.  If there are collisions, the network should not be
             loaded more than perhaps 20%.

             Serial links are limited by the interrupt overhead and the
             interrupt latency.  (Use of DMA is of course a different
             matter.)  Useful speeds are normally 9600-38,400 bits per
             second, or 1000-4000 bytes per second.  At rates this low, any
             processing overhead is small, except for the 8-bit processors.

             In an embedded controller, travel time is often more important                                        ___________
             than data rate.  When the host sends a command to the
             controller, it is often of vital importance that the
             controller reacts within so-and-so many milliseconds.  In
             simple protocols, travel time and data rate are pretty much
             the same thing: if the data rate measured with 1000-byte
             messages is 100,000 bytes per second, then one 1000-byte
             message will take 10 milliseconds to arrive.  In protocols
             such as TCP, the travel time has to measured independently.


             BENCHMARKS             BENCHMARKS

             The speed measurements that follow have been run with the
             program BENCH.  This is included in the USNET release, so that
             you can run your own speed tests.  You need two hosts to run
             the test.  Define the faster of these as SERVER in BENCH.C,
             then issue a make bench (after any needed configuring), then                          __________
             start BENCH first in the server and then in the client.

             The speed tests presented here use the following
             configuration:








                        board to be
            benchmark
                          tested
            server


                                                 33 Mhz 486
                                            Intel EtherExpress 16
                                            Borland C, small model,
                                              default optimization
          0

          All tests use default compiler optimization.  The tested
          hardware and the test code are explained after the tables.

          In data rate measurements, the client sends data to the server             _________
          at full speed.  UDP has no flow control, so this will work
          only if the server is faster than the client.  (This is why
          the SPARClite entry is missing.)  The value bytes is the                                                      _____
          amount of data in one packet.


              DATA RATE kilobytes second              DATA RATE

          +-------- ----- ------ ----- ------ ------ ------ -------+
           protocol  byte  A 386  B     C 386  D 386  E 68k  F SP          |                    |                          |                          |                                 |                                       |                                              |                                                     |                                                            |      |
                     s            386          |                    |                          |                          |                                 |                                       |                                              |                                                     |                                                            |      |
          |-------- +---- |-----                          |      +---- +----- +----- +----- +------|
           TCP/IP    512   290    244   300    581    221    489          |                    |                          |                          |                                 |                                       |                                              |                                                     |                                                            |      |
          |-------- +---- |-----                          |      +---- +----- +----- +----- +------|
                     1024  454    387   379    886    300    744          |                    |                          |                          |                                 |                                       |                                              |                                                     |                                                            |      |
          |-------- +---- |-----                          |      +---- +----- +----- +----- +------|
                     1460  430    408   474    780    336    948          |                    |                          |                          |                                 |                                       |                                              |                                                     |                                                            |      |
          |-------- +---- |-----                          |      +---- +----- +----- +----- +------|
           UDP/IP    512   372    273   423    664    332          |                    |                          |                          |                                 |                                       |                                              |                                                     |                                                            |      |
          |-------- +---- |-----                          |      +---- +----- +----- +----- +------|
                     1024  443    365   454    744    387          |                    |                          |                          |                                 |                                       |                                              |                                                     |                                                            |      |
          |-------- +---- |-----                          |      +---- +----- +----- +----- +------|
                     1460  482    408   474    780    414          |                    |                          |                          |                                 |                                       |                                              |                                                     |                                                            |      |
          |-------- +---- |-----                          |      +---- +----- +----- +----- +------|
           stream          |          +--------  1460                    |                    -----  530                          |                          |                          ------  465                                 |                                 -----  414                                       |                                       ------  780                                              |                                              ------  323                                                     |                                                     ------  948                                                            |      |                                                            -------+

          Travel time is measured as follows.  The client and the server          Travel time
          alternate sending and receiving parcels of data.  One parcel
          is one or more 1460-byte packets, as shown in the table.  The
          result is calculated by dividing the total time with the
          number of shipped parcels






                 TRAVEL TIME millisecond                 TRAVEL TIME

             +----- ----- ----- ----- ----- ----- ----- -------+
                     byte  A386  B386  C386  D386  E68K  FSP             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
              proto  s             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
              col             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
             |----- +---- |----                          |     +---- +---- +---- +---- +------|
              TCP/I  1460  4     4     4     3     6     3             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
              P             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
             |----- +---- |----                          |     +---- +---- +---- +---- +------|
                     5840  12    14    13    7     18    7             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
             |----- +---- |----                          |     +---- +---- +---- +---- +------|
                     2336  48    55    53    30    70    28             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
                     0             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
             |----- +---- |----                          |     +---- +---- +---- +---- +------|
              UDP/I  1460  4     4     4     2     5     3             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
              P             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
             |----- +---- |----                          |     +---- +---- +---- +---- +------|
                     5840  11    13    12    7     16    7             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
             |----- +---- |----                          |     +---- +---- +---- +---- +------|
              strea  1460  4     5     4     3     6     3             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
              m             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
             |----- +---- |----                          |     +---- +---- +---- +---- +------|
                     5840  12    14    13    7     18    7             |                    |                          |                          |                                |                                      |                                            |                                                  |                                                        |      |
             |----- +---- |----                          |     +---- +---- +---- +---- +------|
                     2336  48    55    54    30    70    27             |             |                    |                          |                          |                          |                          |                                |                                |                                      |                                      |                                            |                                            |                                                  |                                                  |                                                        |      |                                                        |      |
             +-----  0                    |                    ----- ----- ----- ----- ----- ----- -------+


             Tested hardware:

                  1.   A 386     16 Mhz 386SX in real mode, Accton NE2000
                    Ethernet card, Borland small model C
                       
                  2.   B 386     16 Mhz 386SX in protected mode, Accton
                    NE2000 Ethernet card, Watcom C
                       
                  3.   C 386     40 Mhz 386 in real mode, WD8003 Ethernet
                    card, Borland small model C
                       
                  4.   D 386     40 Mhz 386 in real mode, AMD 79C960
                    Ethernet card, Borland small model
                       
                  5.   E 68k     25 Mhz 68360 QUADD, MRI C
                       
                  6.   F SP 40 Mhz SPARClite, Fujitsu MB86960 Ethernet, MRI
                    C






          The TCP and the UDP data rate tests used the following
          write/read loops:

            client:   for (lc1=0; lc1<NLOOPS; lc1++)            client
                      {
                          buff2[0] = (char)lc1;
                          status = Nwrite(conno, buff2, bsize);
                          if (status < 0)
                             goto err2;
                      }

            server:   for (lc1=0; lc1<NLOOPS; lc1++)            server
                      {
                          status = Nread(conno, buff1, bsize);
                          if (status != bsize)
                              goto err3;
                          if (buff1[0] != (char)lc1)
                              goto err5;
                      }


          The BSD stream socket data rate test used the following
          read/write loops:

            client:   for (lc1=0; lc1<NLOOPS; lc1++)            client
                      {
                          buff2[0] = (char)lc1;
                          status = send(s, buff2, bsize, 0);
                          if (status < 0)
                               goto err2;
                      }

            server:   for (lc1=0; lc1<NLOOPS; lc1++)            server
                      {
                          status = recv(s2, buff1, bsize, 0);
                          if (status != bsize)
                            goto err3;
                        if (buff1[0] != (char)lc1)
                            goto err5;
                      }






             The TCP and UDP travel time was measured using the following
             pair of loops:

               client:   for (lc1=0; lc1<lcnt; lc1++)               client
                         {
                           for (lc2=0; lc2<lentab[lc3]; lc2++)
                           {
                               status = Nread(conno, buff1, bsize);
                               if (status != bsize)
                                   goto err3;
                               if (buff1[0] != (char)lc1)
                                   goto err5;
                           }
                           for (lc2=0; lc2<lentab[lc3]; lc2++)
                           {
                               buff1[0] = (char)lc1;
                               status = Nwrite(conno, buff1, bsize);
                               if (status < 0)
                                   goto err2;
                           }
                         }

               server:   for (lc1=0; lc1<lcnt; lc1++)               server
                         {
                           for (lc2=0; lc2<lentab[lc3]; lc2++)
                           {
                               buff2[0] = (char)lc1;
                                    status = Nwrite(conno, buff2, bsize);
                                    if (status < 0)
                                   goto err2;
                           }
                           for (lc2=0; lc2<lentab[lc3]; lc2++)
                           {
                                status = Nread(conno, buff2, bsize);
                                if (status != bsize)
                                    goto err3;
                                if (buff2[0] != (char)lc1)
                                    goto err5;
                           }
                       }






          The BSD socket stream travel time was measured using the
          following pair of loops:

            client:   for (lc1=0; lc1<lcnt; lc1++)            client
                      {
                        for (lc2=0; lc2<lentab[lc3]; lc2++)
                        {
                            status = recv(s, buff1, bsize, 0);
                            if (status != bsize)
                                goto err3;
                            if (buff1[0] != (char)lc1)
                                goto err5;
                        }
                        for (lc2=0; lc2<lentab[lc3]; lc2++)
                        {
                            buff1[0] = (char)lc1;
                            status = send(s, buff1, bsize, 0);
                            if (status < 0)
                                goto err2;
                        }
                      }

            server:   for (lc1=0; lc1<lcnt; lc1++)            server
                      {
                        for (lc2=0; lc2<lentab[lc3]; lc2++)
                        {
                            buff2[0] = (char)lc1;
                                 status = send(s, buff2, bsize, 0);
                                 if (status < 0)
                                goto err2;
                        }
                        for (lc2=0; lc2<lentab[lc3]; lc2++)
                        {
                             status = recv(s, buff2, bsize, 0);
                             if (status != bsize)
                                 goto err3;
                             if (buff2[0] != (char)lc1)
                                 goto err5;
                        }
                    }